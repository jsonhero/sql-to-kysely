// src/types.ts
var MemberVisibility = /* @__PURE__ */ ((MemberVisibility2) => {
  MemberVisibility2[MemberVisibility2["Unknown"] = 0] = "Unknown";
  MemberVisibility2[MemberVisibility2["Open"] = 1] = "Open";
  MemberVisibility2[MemberVisibility2["Public"] = 2] = "Public";
  MemberVisibility2[MemberVisibility2["Protected"] = 3] = "Protected";
  MemberVisibility2[MemberVisibility2["Private"] = 4] = "Private";
  MemberVisibility2[MemberVisibility2["FilePrivate"] = 5] = "FilePrivate";
  MemberVisibility2[MemberVisibility2["Library"] = 6] = "Library";
  return MemberVisibility2;
})(MemberVisibility || {});
var Modifier = /* @__PURE__ */ ((Modifier3) => {
  Modifier3[Modifier3["Static"] = 0] = "Static";
  Modifier3[Modifier3["Final"] = 1] = "Final";
  Modifier3[Modifier3["Sealed"] = 2] = "Sealed";
  Modifier3[Modifier3["Abstract"] = 3] = "Abstract";
  Modifier3[Modifier3["Deprecated"] = 4] = "Deprecated";
  Modifier3[Modifier3["Virtual"] = 5] = "Virtual";
  Modifier3[Modifier3["Const"] = 6] = "Const";
  Modifier3[Modifier3["Overwritten"] = 7] = "Overwritten";
  return Modifier3;
})(Modifier || {});
var TypeKind = /* @__PURE__ */ ((TypeKind2) => {
  TypeKind2[TypeKind2["Unknown"] = 0] = "Unknown";
  TypeKind2[TypeKind2["Integer"] = 1] = "Integer";
  TypeKind2[TypeKind2["Float"] = 2] = "Float";
  TypeKind2[TypeKind2["Number"] = 3] = "Number";
  TypeKind2[TypeKind2["String"] = 4] = "String";
  TypeKind2[TypeKind2["Char"] = 5] = "Char";
  TypeKind2[TypeKind2["Boolean"] = 6] = "Boolean";
  TypeKind2[TypeKind2["Class"] = 7] = "Class";
  TypeKind2[TypeKind2["Interface"] = 8] = "Interface";
  TypeKind2[TypeKind2["Array"] = 9] = "Array";
  TypeKind2[TypeKind2["Map"] = 10] = "Map";
  TypeKind2[TypeKind2["Enum"] = 11] = "Enum";
  TypeKind2[TypeKind2["Alias"] = 12] = "Alias";
  return TypeKind2;
})(TypeKind || {});
var ReferenceKind = /* @__PURE__ */ ((ReferenceKind3) => {
  ReferenceKind3[ReferenceKind3["Irrelevant"] = 0] = "Irrelevant";
  ReferenceKind3[ReferenceKind3["Pointer"] = 1] = "Pointer";
  ReferenceKind3[ReferenceKind3["Reference"] = 2] = "Reference";
  ReferenceKind3[ReferenceKind3["Instance"] = 3] = "Instance";
  return ReferenceKind3;
})(ReferenceKind || {});

// src/BaseSymbol.ts
var BaseSymbol = class {
  /** The name of the symbol or empty if anonymous. */
  name;
  /** Reference to the parse tree which contains this symbol. */
  context;
  modifiers = /* @__PURE__ */ new Set();
  visibility = 0 /* Unknown */;
  #parent;
  constructor(name = "") {
    this.name = name;
  }
  get parent() {
    return this.#parent;
  }
  get firstSibling() {
    if (!this.#parent) {
      return void 0;
    }
    return this.#parent?.firstChild;
  }
  /**
   * @returns the symbol before this symbol in its scope.
   */
  get previousSibling() {
    if (!this.#parent) {
      return void 0;
    }
    if (!this.#parent) {
      return this;
    }
    return this.#parent.previousSiblingOf(this);
  }
  /**
   * @returns the symbol following this symbol in its scope.
   */
  get nextSibling() {
    return this.#parent?.nextSiblingOf(this);
  }
  get lastSibling() {
    return this.#parent?.lastChild;
  }
  /**
   * @returns the next symbol in definition order, regardless of the scope.
   */
  get next() {
    return this.#parent?.nextOf(this);
  }
  /**
   * @returns the outermost entity (below the symbol table) that holds us.
   */
  get root() {
    let run = this.#parent;
    while (run) {
      if (!run.parent || this.isSymbolTable(run.parent)) {
        return run;
      }
      run = run.parent;
    }
    return run;
  }
  /**
   * @returns the symbol table we belong too or undefined if we are not yet assigned.
   */
  get symbolTable() {
    if (this.isSymbolTable(this)) {
      return this;
    }
    let run = this.#parent;
    while (run) {
      if (this.isSymbolTable(run)) {
        return run;
      }
      run = run.parent;
    }
    return void 0;
  }
  /**
   * @returns the list of symbols from this one up to root.
   */
  get symbolPath() {
    const result = [];
    let run = this;
    while (run) {
      result.push(run);
      if (!run.parent) {
        break;
      }
      run = run.parent;
    }
    return result;
  }
  /**
   * This is rather an internal method and should rarely be used by external code.
   *
   * @param parent The new parent to use.
   */
  setParent(parent) {
    this.#parent = parent;
  }
  /**
   * Remove this symbol from its parent scope.
   */
  removeFromParent() {
    this.#parent?.removeSymbol(this);
    this.#parent = void 0;
  }
  /**
   * Asynchronously looks up a symbol with a given name, in a bottom-up manner.
   *
   * @param name The name of the symbol to find.
   * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol
   *                  (recursively).
   *
   * @returns A promise resolving to the first symbol with a given name, in the order of appearance in this scope
   *          or any of the parent scopes (conditionally).
   */
  async resolve(name, localOnly = false) {
    return this.#parent?.resolve(name, localOnly);
  }
  /**
   * Synchronously looks up a symbol with a given name, in a bottom-up manner.
   *
   * @param name The name of the symbol to find.
   * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol
   *                  (recursively).
   *
   * @returns the first symbol with a given name, in the order of appearance in this scope
   *          or any of the parent scopes (conditionally).
   */
  resolveSync(name, localOnly = false) {
    return this.#parent?.resolveSync(name, localOnly);
  }
  /**
   * @param t The type of objects to return.
   *
   * @returns the next enclosing parent of the given type.
   */
  getParentOfType(t) {
    let run = this.#parent;
    while (run) {
      if (run instanceof t) {
        return run;
      }
      run = run.parent;
    }
    return void 0;
  }
  /**
   * Creates a qualified identifier from this symbol and its parent.
   * If `full` is true then all parents are traversed in addition to this instance.
   *
   * @param separator The string to be used between the parts.
   * @param full A flag indicating if the full path is to be returned.
   * @param includeAnonymous Use a special string for empty scope names.
   *
   * @returns the constructed qualified identifier.
   */
  qualifiedName(separator = ".", full = false, includeAnonymous = false) {
    if (!includeAnonymous && this.name.length === 0) {
      return "";
    }
    let result = this.name.length === 0 ? "<anonymous>" : this.name;
    let run = this.#parent;
    while (run) {
      if (includeAnonymous || run.name.length > 0) {
        result = (run.name.length === 0 ? "<anonymous>" : run.name) + separator + result;
      }
      if (!full || !run.parent) {
        break;
      }
      run = run.parent;
    }
    return result;
  }
  /**
   * Type guard to check for ISymbolTable.
   *
   * @param candidate The object to check.
   *
   * @returns true if the object is a symbol table.
   */
  isSymbolTable(candidate) {
    return candidate.info !== void 0;
  }
};

// src/ArrayType.ts
var ArrayType = class extends BaseSymbol {
  elementType;
  size;
  // > 0 if fixed length.
  referenceKind;
  constructor(name, referenceKind, elemType, size = 0) {
    super(name);
    this.referenceKind = referenceKind;
    this.elementType = elemType;
    this.size = size;
  }
  get baseTypes() {
    return [];
  }
  get kind() {
    return 9 /* Array */;
  }
  get reference() {
    return this.referenceKind;
  }
};

// src/DuplicateSymbolError.ts
var DuplicateSymbolError = class extends Error {
};

// src/ScopedSymbol.ts
var ScopedSymbol = class _ScopedSymbol extends BaseSymbol {
  /** All child symbols in definition order. */
  #children = [];
  // All used child names. Used to detect name collisions.
  #names = /* @__PURE__ */ new Map();
  constructor(name = "") {
    super(name);
  }
  /**
   * @returns A promise resolving to all direct child symbols with a scope (e.g. classes in a module).
   */
  get directScopes() {
    return this.getSymbolsOfType(_ScopedSymbol);
  }
  get children() {
    return this.#children;
  }
  get firstChild() {
    if (this.#children.length > 0) {
      return this.#children[0];
    }
    return void 0;
  }
  get lastChild() {
    if (this.#children.length > 0) {
      return this.#children[this.#children.length - 1];
    }
    return void 0;
  }
  clear() {
    this.#children = [];
    this.#names.clear();
  }
  /**
   * Adds the given symbol to this scope. If it belongs already to a different scope
   * it is removed from that before adding it here.
   *
   * @param symbol The symbol to add as a child.
   */
  addSymbol(symbol) {
    symbol.removeFromParent();
    const symbolTable = this.symbolTable;
    const count = this.#names.get(symbol.name);
    if (!symbolTable || !symbolTable.options.allowDuplicateSymbols) {
      if (count !== void 0) {
        throw new DuplicateSymbolError("Attempt to add duplicate symbol '" + (symbol.name ?? "<anonymous>") + "'");
      } else {
        this.#names.set(symbol.name, 1);
      }
      const index = this.#children.indexOf(symbol);
      if (index > -1) {
        throw new DuplicateSymbolError("Attempt to add duplicate symbol '" + (symbol.name ?? "<anonymous>") + "'");
      }
    } else {
      this.#names.set(symbol.name, count === void 0 ? 1 : count + 1);
    }
    this.#children.push(symbol);
    symbol.setParent(this);
  }
  removeSymbol(symbol) {
    const index = this.#children.indexOf(symbol);
    if (index > -1) {
      this.#children.splice(index, 1);
      symbol.setParent(void 0);
      const count = this.#names.get(symbol.name);
      if (count !== void 0) {
        if (count === 1) {
          this.#names.delete(symbol.name);
        } else {
          this.#names.set(symbol.name, count - 1);
        }
      }
    }
  }
  /**
   * Asynchronously retrieves child symbols of a given type from this symbol.
   *
   * @param t The type of of the objects to return.
   *
   * @returns A promise resolving to all (nested) children of the given type.
   */
  async getNestedSymbolsOfType(t) {
    const result = [];
    const childPromises = [];
    this.#children.forEach((child) => {
      if (child instanceof t) {
        result.push(child);
      }
      if (child instanceof _ScopedSymbol) {
        childPromises.push(child.getNestedSymbolsOfType(t));
      }
    });
    const childSymbols = await Promise.all(childPromises);
    childSymbols.forEach((entry) => {
      result.push(...entry);
    });
    return result;
  }
  /**
   * Synchronously retrieves child symbols of a given type from this symbol.
   *
   * @param t The type of of the objects to return.
   *
   * @returns A list of all (nested) children of the given type.
   */
  getNestedSymbolsOfTypeSync(t) {
    const result = [];
    this.#children.forEach((child) => {
      if (child instanceof t) {
        result.push(child);
      }
      if (child instanceof _ScopedSymbol) {
        result.push(...child.getNestedSymbolsOfTypeSync(t));
      }
    });
    return result;
  }
  /**
   * @param name If given only returns symbols with that name.
   *
   * @returns A promise resolving to symbols from this and all nested scopes in the order they were defined.
   */
  async getAllNestedSymbols(name) {
    const result = [];
    const childPromises = [];
    this.#children.forEach((child) => {
      if (!name || child.name === name) {
        result.push(child);
      }
      if (child instanceof _ScopedSymbol) {
        childPromises.push(child.getAllNestedSymbols(name));
      }
    });
    const childSymbols = await Promise.all(childPromises);
    childSymbols.forEach((entry) => {
      result.push(...entry);
    });
    return result;
  }
  /**
   * @param name If given only returns symbols with that name.
   *
   * @returns A list of all symbols from this and all nested scopes in the order they were defined.
   */
  getAllNestedSymbolsSync(name) {
    const result = [];
    this.#children.forEach((child) => {
      if (!name || child.name === name) {
        result.push(child);
      }
      if (child instanceof _ScopedSymbol) {
        result.push(...child.getAllNestedSymbolsSync(name));
      }
    });
    return result;
  }
  /**
   * @param t The type of of the objects to return.
   *
   * @returns A promise resolving to direct children of a given type.
   */
  getSymbolsOfType(t) {
    return new Promise((resolve) => {
      const result = [];
      this.#children.forEach((child) => {
        if (child instanceof t) {
          result.push(child);
        }
      });
      resolve(result);
    });
  }
  /**
   * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).
   *
   * @param t The type of the objects to return.
   * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol
   *                  (recursively).
   *
   * @returns A promise resolving to all symbols of the the given type, accessible from this scope (if localOnly is
   *          false), within the owning symbol table.
   */
  async getAllSymbols(t, localOnly = false) {
    const result = [];
    for (const child of this.#children) {
      if (child instanceof t) {
        result.push(child);
      }
      if (this.isNamespace(child)) {
        const childSymbols = await child.getAllSymbols(t, true);
        result.push(...childSymbols);
      }
    }
    if (!localOnly) {
      if (this.parent) {
        const childSymbols = await this.getAllSymbols(t, true);
        result.push(...childSymbols);
      }
    }
    return result;
  }
  /**
   * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).
   *
   * @param t The type of the objects to return.
   * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol
   *                  (recursively).
   *
   * @returns A list with all symbols of the the given type, accessible from this scope (if localOnly is
   *          false), within the owning symbol table.
   */
  getAllSymbolsSync(t, localOnly = false) {
    const result = [];
    for (const child of this.#children) {
      if (child instanceof t) {
        result.push(child);
      }
      if (this.isNamespace(child)) {
        const childSymbols = child.getAllSymbolsSync(t, true);
        result.push(...childSymbols);
      }
    }
    if (!localOnly) {
      if (this.parent) {
        const childSymbols = this.getAllSymbolsSync(t, true);
        result.push(...childSymbols);
      }
    }
    return result;
  }
  /**
   * @param name The name of the symbol to resolve.
   * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol
   *                  (recursively).
   *
   * @returns A promise resolving to the first symbol with a given name, in the order of appearance in this scope
   *          or any of the parent scopes (conditionally).
   */
  async resolve(name, localOnly = false) {
    return new Promise((resolve) => {
      for (const child of this.#children) {
        if (child.name === name) {
          resolve(child);
          return;
        }
      }
      if (!localOnly) {
        if (this.parent) {
          resolve(this.parent.resolve(name, false));
          return;
        }
      }
      resolve(void 0);
    });
  }
  /**
   * @param name The name of the symbol to resolve.
   * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol
   *                  (recursively).
   *
   * @returns the first symbol with a given name, in the order of appearance in this scope
   *          or any of the parent scopes (conditionally).
   */
  resolveSync(name, localOnly = false) {
    for (const child of this.#children) {
      if (child.name === name) {
        return child;
      }
    }
    if (!localOnly) {
      if (this.parent) {
        return this.parent.resolveSync(name, false);
      }
    }
    return void 0;
  }
  /**
   * @param path The path consisting of symbol names separator by `separator`.
   * @param separator The character to separate path segments.
   *
   * @returns the symbol located at the given path through the symbol hierarchy.
   */
  symbolFromPath(path, separator = ".") {
    const elements = path.split(separator);
    let index = 0;
    if (elements[0] === this.name || elements[0].length === 0) {
      ++index;
    }
    let result = this;
    while (index < elements.length) {
      if (!(result instanceof _ScopedSymbol)) {
        return void 0;
      }
      const child = result.children.find((candidate) => {
        return candidate.name === elements[index];
      });
      if (!child) {
        return void 0;
      }
      result = child;
      ++index;
    }
    return result;
  }
  /**
   * @param child The child to search for.
   *
   * @returns the index of the given child symbol in the child list or -1 if it couldn't be found.
   */
  indexOfChild(child) {
    return this.#children.findIndex((value) => {
      return value === child;
    });
  }
  /**
   * @param child The reference node.
   *
   * @returns the sibling symbol after the given child symbol, if one exists.
   */
  nextSiblingOf(child) {
    const index = this.indexOfChild(child);
    if (index === -1 || index >= this.#children.length - 1) {
      return void 0;
    }
    return this.#children[index + 1];
  }
  /**
   * @param child The reference node.
   *
   * @returns the sibling symbol before the given child symbol, if one exists.
   */
  previousSiblingOf(child) {
    const index = this.indexOfChild(child);
    if (index < 1) {
      return void 0;
    }
    return this.#children[index - 1];
  }
  /**
   * @param child The reference node.
   *
   * @returns the next symbol in definition order, regardless of the scope.
   */
  nextOf(child) {
    if (!child.parent) {
      return void 0;
    }
    if (child.parent !== this) {
      return child.parent.nextOf(child);
    }
    if (child instanceof _ScopedSymbol && child.children.length > 0) {
      return child.children[0];
    }
    const sibling = this.nextSiblingOf(child);
    if (sibling) {
      return sibling;
    }
    return this.parent.nextOf(this);
  }
  isNamespace(candidate) {
    return candidate.inline !== void 0 && candidate.attributes !== void 0;
  }
};

// src/BlockSymbol.ts
var BlockSymbol = class extends ScopedSymbol {
};

// src/TypedSymbol.ts
var TypedSymbol = class extends BaseSymbol {
  type;
  constructor(name, type) {
    super(name);
    this.type = type;
  }
};

// src/VariableSymbol.ts
var VariableSymbol = class extends TypedSymbol {
  value;
  constructor(name, value, type) {
    super(name, type);
    this.value = value;
  }
};

// src/FieldSymbol.ts
var FieldSymbol = class extends VariableSymbol {
  setter;
  getter;
};

// src/ParameterSymbol.ts
var ParameterSymbol = class extends VariableSymbol {
};

// src/RoutineSymbol.ts
var RoutineSymbol = class extends ScopedSymbol {
  returnType;
  // Can be null if result is void.
  constructor(name, returnType) {
    super(name);
    this.returnType = returnType;
  }
  getVariables(_localOnly = true) {
    return this.getSymbolsOfType(VariableSymbol);
  }
  getParameters(_localOnly = true) {
    return this.getSymbolsOfType(ParameterSymbol);
  }
};

// src/MethodSymbol.ts
var MethodFlags = /* @__PURE__ */ ((MethodFlags2) => {
  MethodFlags2[MethodFlags2["None"] = 0] = "None";
  MethodFlags2[MethodFlags2["Virtual"] = 1] = "Virtual";
  MethodFlags2[MethodFlags2["Const"] = 2] = "Const";
  MethodFlags2[MethodFlags2["Overwritten"] = 4] = "Overwritten";
  MethodFlags2[MethodFlags2["SetterOrGetter"] = 8] = "SetterOrGetter";
  MethodFlags2[MethodFlags2["Explicit"] = 16] = "Explicit";
  return MethodFlags2;
})(MethodFlags || {});
var MethodSymbol = class extends RoutineSymbol {
  methodFlags = 0 /* None */;
};

// src/ClassSymbol.ts
var ClassSymbol = class extends ScopedSymbol {
  isStruct = false;
  reference = 0 /* Irrelevant */;
  /** Usually only one member, unless the language supports multiple inheritance (like C++). */
  // eslint-disable-next-line no-use-before-define
  extends;
  /** Typescript allows a class to implement a class, not only interfaces. */
  // eslint-disable-next-line no-use-before-define
  implements;
  constructor(name, ext, impl) {
    super(name);
    this.extends = ext;
    this.implements = impl;
  }
  get baseTypes() {
    return this.extends;
  }
  get kind() {
    return 7 /* Class */;
  }
  /**
   * @param _includeInherited Not used.
   *
   * @returns a list of all methods.
   */
  getMethods(_includeInherited = false) {
    return this.getSymbolsOfType(MethodSymbol);
  }
  /**
   * @param _includeInherited Not used.
   *
   * @returns all fields.
   */
  getFields(_includeInherited = false) {
    return this.getSymbolsOfType(FieldSymbol);
  }
};

// src/FundamentalType.ts
var FundamentalType = class _FundamentalType {
  static integerType = new _FundamentalType("int", 1 /* Integer */, 3 /* Instance */);
  static floatType = new _FundamentalType("float", 2 /* Float */, 3 /* Instance */);
  static stringType = new _FundamentalType("string", 4 /* String */, 3 /* Instance */);
  static boolType = new _FundamentalType("bool", 6 /* Boolean */, 3 /* Instance */);
  name;
  typeKind;
  referenceKind;
  constructor(name, typeKind = 0 /* Unknown */, referenceKind = 0 /* Irrelevant */) {
    this.name = name;
    this.typeKind = typeKind;
    this.referenceKind = referenceKind;
  }
  get baseTypes() {
    return [];
  }
  get kind() {
    return this.typeKind;
  }
  get reference() {
    return this.referenceKind;
  }
};

// src/InterfaceSymbol.ts
var InterfaceSymbol = class extends ScopedSymbol {
  reference = 0 /* Irrelevant */;
  /** Typescript allows an interface to extend a class, not only interfaces. */
  // eslint-disable-next-line no-use-before-define
  extends;
  constructor(name, ext) {
    super(name);
    this.extends = ext;
  }
  get baseTypes() {
    return this.extends;
  }
  get kind() {
    return 8 /* Interface */;
  }
  /**
   * @param _includeInherited not used
   *
   * @returns a list of all methods.
   */
  getMethods(_includeInherited = false) {
    return this.getSymbolsOfType(MethodSymbol);
  }
  /**
   * @param _includeInherited Not used.
   *
   * @returns all fields.
   */
  getFields(_includeInherited = false) {
    return this.getSymbolsOfType(FieldSymbol);
  }
};

// src/LiteralSymbol.ts
var LiteralSymbol = class extends TypedSymbol {
  value;
  constructor(name, value, type) {
    super(name, type);
    this.value = value;
  }
};

// src/NamespaceSymbol.ts
var NamespaceSymbol = class extends ScopedSymbol {
  inline;
  attributes;
  constructor(name, inline = false, attributes = []) {
    super(name);
    this.inline = inline;
    this.attributes = attributes;
  }
};

// src/TypeAlias.ts
var TypeAlias = class extends BaseSymbol {
  targetType;
  constructor(name, target) {
    super(name);
    this.targetType = target;
  }
  get baseTypes() {
    return [this.targetType];
  }
  get kind() {
    return 12 /* Alias */;
  }
  get reference() {
    return 0 /* Irrelevant */;
  }
};

// node_modules/antlr4ng/dist/antlr4.mjs
var h = class {
  constructor() {
    this.source = null, this.type = null, this.channel = null, this.start = null, this.stop = null, this.tokenIndex = null, this.line = null, this.column = null, this._text = null;
  }
  getTokenSource() {
    return this.source[0];
  }
  getInputStream() {
    return this.source[1];
  }
  get text() {
    return this._text;
  }
  set text(t) {
    this._text = t;
  }
};
h.INVALID_TYPE = 0;
h.EPSILON = -2;
h.MIN_USER_TOKEN_TYPE = 1;
h.EOF = -1;
h.DEFAULT_CHANNEL = 0;
h.HIDDEN_CHANNEL = 1;
var Ft = class {
  create(t, e, n, s, r, o, l, a) {
  }
};
var ft = class i extends h {
  constructor(t, e, n, s, r) {
    super(), this.source = t !== void 0 ? t : i.EMPTY_SOURCE, this.type = e !== void 0 ? e : null, this.channel = n !== void 0 ? n : h.DEFAULT_CHANNEL, this.start = s !== void 0 ? s : -1, this.stop = r !== void 0 ? r : -1, this.tokenIndex = -1, this.source[0] !== null ? (this.line = t[0].line, this.column = t[0].column) : this.column = -1;
  }
  clone() {
    let t = new i(this.source, this.type, this.channel, this.start, this.stop);
    return t.tokenIndex = this.tokenIndex, t.line = this.line, t.column = this.column, t.text = this.text, t;
  }
  cloneWithType(t) {
    let e = new i(this.source, t, this.channel, this.start, this.stop);
    return e.tokenIndex = this.tokenIndex, e.line = this.line, e.column = this.column, t === h.EOF && (e.text = ""), e;
  }
  toString(t) {
    let e = "";
    this._channel > 0 && (e = ",channel=" + this.channel);
    let n = this.text;
    n ? (n = n.replace(/\n/g, "\\n"), n = n.replace(/\r/g, "\\r"), n = n.replace(/\t/g, "\\t")) : n = "<no text>";
    let s = String(this.type);
    return t && (s = t.vocabulary.getDisplayName(this.type)), "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + n + "',<" + s + ">" + e + "," + this.line + ":" + this.column + "]";
  }
  get text() {
    if (this._text !== null)
      return this._text;
    let t = this.getInputStream();
    if (t === null)
      return null;
    let e = t.size;
    return this.start < e && this.stop < e ? t.getText(this.start, this.stop) : "<EOF>";
  }
  set text(t) {
    this._text = t;
  }
};
ft.EMPTY_SOURCE = [null, null];
var g = class i2 {
  constructor(t, e) {
    this.start = t, this.stop = e;
  }
  static of(t, e) {
    return t != e || t < 0 || t > i2.INTERVAL_POOL_MAX_VALUE ? new i2(t, e) : (i2.cache[t] === null && (i2.cache[t] = new i2(t, t)), i2.cache[t]);
  }
  equals(t) {
    return t instanceof i2 ? this.start === t.start && this.stop === t.stop : false;
  }
  hashCode() {
    let t = 23;
    return t = t * 31 + this.start, t = t * 31 + this.stop, t;
  }
  startsBeforeDisjoint(t) {
    return this.start < t.start && this.stop < t.start;
  }
  startsBeforeNonDisjoint(t) {
    return this.start <= t.start && this.stop >= t.start;
  }
  startsAfter(t) {
    return this.start > t.start;
  }
  startsAfterDisjoint(t) {
    return this.start > t.stop;
  }
  startsAfterNonDisjoint(t) {
    return this.start > t.start && this.start <= t.stop;
  }
  disjoint(t) {
    return this.startsBeforeDisjoint(t) || this.startsAfterDisjoint(t);
  }
  adjacent(t) {
    return this.start === t.stop + 1 || this.stop === t.start - 1;
  }
  properlyContains(t) {
    return t.start >= this.start && t.stop <= this.stop;
  }
  union(t) {
    return i2.of(Math.min(this.start, t.start), Math.max(this.stop, t.stop));
  }
  intersection(t) {
    return i2.of(Math.max(this.start, t.start), Math.min(this.stop, t.stop));
  }
  differenceNotProperlyContained(t) {
    let e = null;
    return t.startsBeforeNonDisjoint(this) ? e = i2.of(Math.max(this.start, t.stop + 1), this.stop) : t.startsAfterNonDisjoint(this) && (e = i2.of(this.start, t.start - 1)), e;
  }
  toString() {
    return this.start === this.stop ? this.start.toString() : this.start.toString() + ".." + this.stop.toString();
  }
  get length() {
    return this.stop < this.start ? 0 : this.stop - this.start + 1;
  }
};
g.INVALID_INTERVAL = new g(-1, -2);
g.INTERVAL_POOL_MAX_VALUE = 1e3;
g.cache = new Array(g.INTERVAL_POOL_MAX_VALUE + 1);
g.cache.fill(null);
var $ = class {
  syntaxError(t, e, n, s, r, o) {
  }
  reportAmbiguity(t, e, n, s, r, o, l) {
  }
  reportAttemptingFullContext(t, e, n, s, r, o) {
  }
  reportContextSensitivity(t, e, n, s, r, o) {
  }
};
var vt = class extends $ {
  constructor() {
    super();
  }
  syntaxError(t, e, n, s, r, o) {
    console.error("line " + n + ":" + s + " " + r);
  }
};
vt.INSTANCE = new vt();
var me = class extends $ {
  constructor(t) {
    if (super(), t === null)
      throw "delegates";
    return this.delegates = t, this;
  }
  syntaxError(t, e, n, s, r, o) {
    this.delegates.map((l) => l.syntaxError(t, e, n, s, r, o));
  }
  reportAmbiguity(t, e, n, s, r, o, l) {
    this.delegates.map((a) => a.reportAmbiguity(t, e, n, s, r, o, l));
  }
  reportAttemptingFullContext(t, e, n, s, r, o) {
    this.delegates.map((l) => l.reportAttemptingFullContext(t, e, n, s, r, o));
  }
  reportContextSensitivity(t, e, n, s, r, o) {
    this.delegates.map((l) => l.reportContextSensitivity(t, e, n, s, r, o));
  }
};
var bt = class i3 {
  static EOF = -1;
  static tokenTypeMapCache = /* @__PURE__ */ new Map();
  static ruleIndexMapCache = /* @__PURE__ */ new Map();
  constructor() {
    this._listeners = [vt.INSTANCE], this.interpreter = null, this._stateNumber = -1;
  }
  checkVersion(t) {
    let e = "4.13.1";
    e !== t && console.log("ANTLR runtime and generated code versions disagree: " + e + "!=" + t);
  }
  addErrorListener(t) {
    this._listeners.push(t);
  }
  removeErrorListeners() {
    this._listeners = [];
  }
  getTokenTypeMap() {
    let t = this.vocabulary, e = i3.tokenTypeMapCache.get(t);
    if (!e) {
      e = /* @__PURE__ */ new Map();
      for (let n = 0; n <= this.atn.maxTokenType; n++) {
        let s = t.getLiteralName(n);
        s && e.set(s, n);
        let r = t.getSymbolicName(n);
        r && e.set(r, n);
      }
      e.set("EOF", h.EOF), i3.tokenTypeMapCache.set(t, e);
    }
    return e;
  }
  getRuleIndexMap() {
    let t = this.ruleNames, e = i3.ruleIndexMapCache.get(t);
    return e || (e = /* @__PURE__ */ new Map(), t.forEach((n, s) => e.set(n, s)), i3.ruleIndexMapCache.set(t, e)), e;
  }
  getTokenType(t) {
    let e = this.getTokenTypeMap().get(t);
    return e || h.INVALID_TYPE;
  }
  getErrorHeader(t) {
    let e = t.offendingToken.line, n = t.offendingToken.column;
    return "line " + e + ":" + n;
  }
  getTokenErrorDisplay(t) {
    if (t === null)
      return "<no token>";
    let e = t.text;
    return e === null && (t.type === h.EOF ? e = "<EOF>" : e = "<" + t.type + ">"), e = e.replace(`
`, "\\n").replace("\r", "\\r").replace("	", "\\t"), "'" + e + "'";
  }
  getErrorListenerDispatch() {
    return new me(this._listeners);
  }
  sempred(t, e, n) {
    return true;
  }
  precpred(t, e) {
    return true;
  }
  get atn() {
    return this.interpreter.atn;
  }
  get state() {
    return this._stateNumber;
  }
  set state(t) {
    this._stateNumber = t;
  }
};
var Mt = class extends Ft {
  constructor(t) {
    super(), this.copyText = t === void 0 ? false : t;
  }
  create(t, e, n, s, r, o, l, a) {
    let u = new ft(t, e, s, r, o);
    return u.line = l, u.column = a, n !== null ? u.text = n : this.copyText && t[1] !== null && (u.text = t[1].getText(r, o)), u;
  }
  createThin(t, e) {
    let n = new ft(null, t);
    return n.text = e, n;
  }
};
Mt.DEFAULT = new Mt();
var M = class i4 extends Error {
  constructor(t) {
    super(t.message), Error.captureStackTrace && Error.captureStackTrace(this, i4), this.message = t.message, this.recognizer = t.recognizer, this.input = t.input, this.ctx = t.ctx, this.offendingToken = null, this.offendingState = -1, this.recognizer !== null && (this.offendingState = this.recognizer.state);
  }
  getExpectedTokens() {
    return this.recognizer !== null ? this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx) : null;
  }
  toString() {
    return this.message;
  }
};
var rt = class extends M {
  constructor(t, e, n, s) {
    super({ message: "", recognizer: t, input: e, ctx: null }), this.startIndex = n, this.deadEndConfigs = s;
  }
  toString() {
    let t = "";
    return this.startIndex >= 0 && this.startIndex < this.input.size && (t = this.input.getText(new g(this.startIndex, this.startIndex))), "LexerNoViableAltException" + t;
  }
};
var N = class i5 extends bt {
  constructor(t) {
    super(), this._input = t, this._factory = Mt.DEFAULT, this._tokenFactorySourcePair = [this, t], this.interpreter = null, this._token = null, this._tokenStartCharIndex = -1, this._tokenStartLine = -1, this._tokenStartColumn = -1, this._hitEOF = false, this._channel = h.DEFAULT_CHANNEL, this._type = h.INVALID_TYPE, this._modeStack = [], this._mode = i5.DEFAULT_MODE, this._text = null;
  }
  reset() {
    this._input !== null && this._input.seek(0), this._token = null, this._type = h.INVALID_TYPE, this._channel = h.DEFAULT_CHANNEL, this._tokenStartCharIndex = -1, this._tokenStartColumn = -1, this._tokenStartLine = -1, this._text = null, this._hitEOF = false, this._mode = i5.DEFAULT_MODE, this._modeStack = [], this.interpreter.reset();
  }
  nextToken() {
    if (this._input === null)
      throw "nextToken requires a non-null input stream.";
    let t = this._input.mark();
    try {
      for (; ; ) {
        if (this._hitEOF)
          return this.emitEOF(), this._token;
        this._token = null, this._channel = h.DEFAULT_CHANNEL, this._tokenStartCharIndex = this._input.index, this._tokenStartColumn = this.interpreter.column, this._tokenStartLine = this.interpreter.line, this._text = null;
        let e = false;
        for (; ; ) {
          this._type = h.INVALID_TYPE;
          let n = i5.SKIP;
          try {
            n = this.interpreter.match(this._input, this._mode);
          } catch (s) {
            if (s instanceof M)
              this.notifyListeners(s), this.recover(s);
            else
              throw console.log(s.stack), s;
          }
          if (this._input.LA(1) === h.EOF && (this._hitEOF = true), this._type === h.INVALID_TYPE && (this._type = n), this._type === i5.SKIP) {
            e = true;
            break;
          }
          if (this._type !== i5.MORE)
            break;
        }
        if (!e)
          return this._token === null && this.emit(), this._token;
      }
    } finally {
      this._input.release(t);
    }
  }
  skip() {
    this._type = i5.SKIP;
  }
  more() {
    this._type = i5.MORE;
  }
  mode(t) {
    this._mode = t;
  }
  pushMode(t) {
    this.interpreter.debug && console.log("pushMode " + t), this._modeStack.push(this._mode), this.mode(t);
  }
  popMode() {
    if (this._modeStack.length === 0)
      throw "Empty Stack";
    return this.interpreter.debug && console.log("popMode back to " + this._modeStack.slice(0, -1)), this.mode(this._modeStack.pop()), this._mode;
  }
  emitToken(t) {
    this._token = t;
  }
  emit() {
    let t = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
    return this.emitToken(t), t;
  }
  emitEOF() {
    let t = this.column, e = this.line, n = this._factory.create(this._tokenFactorySourcePair, h.EOF, null, h.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, e, t);
    return this.emitToken(n), n;
  }
  getCharIndex() {
    return this._input.index;
  }
  getAllTokens() {
    let t = [], e = this.nextToken();
    for (; e.type !== h.EOF; )
      t.push(e), e = this.nextToken();
    return t;
  }
  notifyListeners(t) {
    let e = this._tokenStartCharIndex, n = this._input.index, s = this._input.getText(e, n), r = "token recognition error at: '" + this.getErrorDisplay(s) + "'";
    this.getErrorListenerDispatch().syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, r, t);
  }
  getErrorDisplay(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
      e.push(t[n]);
    return e.join("");
  }
  getErrorDisplayForChar(t) {
    return t.charCodeAt(0) === h.EOF ? "<EOF>" : t === `
` ? "\\n" : t === "	" ? "\\t" : t === "\r" ? "\\r" : t;
  }
  getCharErrorDisplay(t) {
    return "'" + this.getErrorDisplayForChar(t) + "'";
  }
  recover(t) {
    this._input.LA(1) !== h.EOF && (t instanceof rt ? this.interpreter.consume(this._input) : this._input.consume());
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(t) {
    this._input = null, this._tokenFactorySourcePair = [this, null], this.reset(), this._input = t, this._tokenFactorySourcePair = [this, t];
  }
  get sourceName() {
    return this._input.sourceName;
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
  }
  get line() {
    return this.interpreter.line;
  }
  set line(t) {
    this.interpreter.line = t;
  }
  get column() {
    return this.interpreter.column;
  }
  set column(t) {
    this.interpreter.column = t;
  }
  get text() {
    return this._text !== null ? this._text : this.interpreter.getText(this._input);
  }
  set text(t) {
    this._text = t;
  }
};
N.DEFAULT_MODE = 0;
N.MORE = -2;
N.SKIP = -3;
N.DEFAULT_TOKEN_CHANNEL = h.DEFAULT_CHANNEL;
N.HIDDEN = h.HIDDEN_CHANNEL;
N.MIN_CHAR_VALUE = 0;
N.MAX_CHAR_VALUE = 1114111;
var Bt = class {
};
var w = class extends Bt {
};
var it = class extends w {
};
var dt = class extends w {
  constructor(t) {
    super(), this._parent = null, this.symbol = t;
  }
  getChild(t) {
    return null;
  }
  getSymbol() {
    return this.symbol;
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  getPayload() {
    return this.symbol;
  }
  getSourceInterval() {
    if (this.symbol === null)
      return g.INVALID_INTERVAL;
    let t = this.symbol.tokenIndex;
    return new g(t, t);
  }
  getChildCount() {
    return 0;
  }
  accept(t) {
    return t.visitTerminal(this);
  }
  getText() {
    return this.symbol.text;
  }
  toString() {
    return this.symbol.type === h.EOF ? "<EOF>" : this.symbol.text;
  }
  toStringTree() {
    return this.toString();
  }
};
var Lt = class extends dt {
  constructor(t) {
    super(t);
  }
  isErrorNode() {
    return true;
  }
  accept(t) {
    return t.visitErrorNode(this);
  }
};
function pt(i32, t) {
  if (!Array.isArray(i32) || !Array.isArray(t))
    return false;
  if (i32 === t)
    return true;
  if (i32.length !== t.length)
    return false;
  for (let e = 0; e < i32.length; e++)
    if (i32[e] !== t[e] && (!i32[e].equals || !i32[e].equals(t[e])))
      return false;
  return true;
}
var ln = Math.round(Math.random() * Math.pow(2, 32));
function ge(i32) {
  if (!i32)
    return 0;
  let t = typeof i32, e = t === "string" ? i32 : t === "object" && i32.toString ? i32.toString() : false;
  if (!e)
    return 0;
  let n, s, r = e.length & 3, o = e.length - r, l = ln, a = 3432918353, u = 461845907, c = 0;
  for (; c < o; )
    s = e.charCodeAt(c) & 255 | (e.charCodeAt(++c) & 255) << 8 | (e.charCodeAt(++c) & 255) << 16 | (e.charCodeAt(++c) & 255) << 24, ++c, s = (s & 65535) * a + (((s >>> 16) * a & 65535) << 16) & 4294967295, s = s << 15 | s >>> 17, s = (s & 65535) * u + (((s >>> 16) * u & 65535) << 16) & 4294967295, l ^= s, l = l << 13 | l >>> 19, n = (l & 65535) * 5 + (((l >>> 16) * 5 & 65535) << 16) & 4294967295, l = (n & 65535) + 27492 + (((n >>> 16) + 58964 & 65535) << 16);
  switch (s = 0, r) {
    case 3:
      s ^= (e.charCodeAt(c + 2) & 255) << 16;
    case 2:
      s ^= (e.charCodeAt(c + 1) & 255) << 8;
    case 1:
      s ^= e.charCodeAt(c) & 255, s = (s & 65535) * a + (((s >>> 16) * a & 65535) << 16) & 4294967295, s = s << 15 | s >>> 17, s = (s & 65535) * u + (((s >>> 16) * u & 65535) << 16) & 4294967295, l ^= s;
  }
  return l ^= e.length, l ^= l >>> 16, l = (l & 65535) * 2246822507 + (((l >>> 16) * 2246822507 & 65535) << 16) & 4294967295, l ^= l >>> 13, l = (l & 65535) * 3266489909 + (((l >>> 16) * 3266489909 & 65535) << 16) & 4294967295, l ^= l >>> 16, l >>> 0;
}
var R = class i6 {
  constructor() {
    this.count = 0, this.hash = 0;
  }
  update() {
    for (let t = 0; t < arguments.length; t++) {
      let e = arguments[t];
      if (e != null)
        if (Array.isArray(e))
          this.update.apply(this, e);
        else {
          let n = 0;
          switch (typeof e) {
            case "undefined":
            case "function":
              continue;
            case "number":
            case "boolean":
              n = e;
              break;
            case "string":
              n = ge(e);
              break;
            default:
              e.updateHashCode ? e.updateHashCode(this) : console.log("No updateHashCode for " + e.toString());
              continue;
          }
          n = n * 3432918353, n = n << 15 | n >>> 32 - 15, n = n * 461845907, this.count = this.count + 1;
          let s = this.hash ^ n;
          s = s << 13 | s >>> 32 - 13, s = s * 5 + 3864292196, this.hash = s;
        }
    }
  }
  finish() {
    let t = this.hash ^ this.count * 4;
    return t = t ^ t >>> 16, t = t * 2246822507, t = t ^ t >>> 13, t = t * 3266489909, t = t ^ t >>> 16, t;
  }
  static hashStuff() {
    let t = new i6();
    return t.update.apply(t, arguments), t.finish();
  }
};
function Te(i32) {
  return i32 ? typeof i32 == "string" ? ge(i32) : i32.hashCode() : -1;
}
function Se(i32, t) {
  return i32 ? i32.equals(t) : i32 === t;
}
function en(i32) {
  return i32 === null ? "null" : i32;
}
function G(i32) {
  return Array.isArray(i32) ? "[" + i32.map(en).join(", ") + "]" : "null";
}
var Ee = "h-";
var k = class {
  constructor(t, e) {
    this.data = {}, this.hashFunction = t || Te, this.equalsFunction = e || Se;
  }
  add(t) {
    let e = Ee + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++)
        if (this.equalsFunction(t, n[s]))
          return n[s];
      return n.push(t), t;
    } else
      return this.data[e] = [t], t;
  }
  has(t) {
    return this.get(t) != null;
  }
  get(t) {
    let e = Ee + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++)
        if (this.equalsFunction(t, n[s]))
          return n[s];
    }
    return null;
  }
  values() {
    return Object.keys(this.data).filter((t) => t.startsWith(Ee)).flatMap((t) => this.data[t], this);
  }
  toString() {
    return G(this.values());
  }
  get length() {
    return Object.keys(this.data).filter((t) => t.startsWith(Ee)).map((t) => this.data[t].length, this).reduce((t, e) => t + e, 0);
  }
};
var T = class i7 {
  hashCode() {
    let t = new R();
    return this.updateHashCode(t), t.finish();
  }
  evaluate(t, e) {
  }
  evalPrecedence(t, e) {
    return this;
  }
  static andContext(t, e) {
    if (t === null || t === i7.NONE)
      return e;
    if (e === null || e === i7.NONE)
      return t;
    let n = new $e(t, e);
    return n.opnds.length === 1 ? n.opnds[0] : n;
  }
  static orContext(t, e) {
    if (t === null)
      return e;
    if (e === null)
      return t;
    if (t === i7.NONE || e === i7.NONE)
      return i7.NONE;
    let n = new Je(t, e);
    return n.opnds.length === 1 ? n.opnds[0] : n;
  }
};
var $e = class i8 extends T {
  constructor(t, e) {
    super();
    let n = new k();
    t instanceof i8 ? t.opnds.map(function(r) {
      n.add(r);
    }) : n.add(t), e instanceof i8 ? e.opnds.map(function(r) {
      n.add(r);
    }) : n.add(e);
    let s = nn(n);
    if (s.length > 0) {
      let r = null;
      s.map(function(o) {
        (r === null || o.precedence < r.precedence) && (r = o);
      }), n.add(r);
    }
    this.opnds = Array.from(n.values());
  }
  equals(t) {
    return this === t ? true : t instanceof i8 ? pt(this.opnds, t.opnds) : false;
  }
  updateHashCode(t) {
    t.update(this.opnds, "AND");
  }
  evaluate(t, e) {
    for (let n = 0; n < this.opnds.length; n++)
      if (!this.opnds[n].evaluate(t, e))
        return false;
    return true;
  }
  evalPrecedence(t, e) {
    let n = false, s = [];
    for (let o = 0; o < this.opnds.length; o++) {
      let l = this.opnds[o], a = l.evalPrecedence(t, e);
      if (n |= a !== l, a === null)
        return null;
      a !== T.NONE && s.push(a);
    }
    if (!n)
      return this;
    if (s.length === 0)
      return T.NONE;
    let r = null;
    return s.map(function(o) {
      r = r === null ? o : T.andContext(r, o);
    }), r;
  }
  toString() {
    let t = this.opnds.map((e) => e.toString());
    return (t.length > 3 ? t.slice(3) : t).join("&&");
  }
};
var Je = class i9 extends T {
  constructor(t, e) {
    super();
    let n = new k();
    t instanceof i9 ? t.opnds.map(function(r) {
      n.add(r);
    }) : n.add(t), e instanceof i9 ? e.opnds.map(function(r) {
      n.add(r);
    }) : n.add(e);
    let s = nn(n);
    if (s.length > 0) {
      let r = s.sort(function(l, a) {
        return l.compareTo(a);
      }), o = r[r.length - 1];
      n.add(o);
    }
    this.opnds = Array.from(n.values());
  }
  equals(t) {
    return this === t ? true : t instanceof i9 ? pt(this.opnds, t.opnds) : false;
  }
  updateHashCode(t) {
    t.update(this.opnds, "OR");
  }
  evaluate(t, e) {
    for (let n = 0; n < this.opnds.length; n++)
      if (this.opnds[n].evaluate(t, e))
        return true;
    return false;
  }
  evalPrecedence(t, e) {
    let n = false, s = [];
    for (let o = 0; o < this.opnds.length; o++) {
      let l = this.opnds[o], a = l.evalPrecedence(t, e);
      if (n |= a !== l, a === T.NONE)
        return T.NONE;
      a !== null && s.push(a);
    }
    if (!n)
      return this;
    if (s.length === 0)
      return null;
    let r = null;
    return s.map(function(o) {
      return r === null ? o : T.orContext(r, o);
    }), r;
  }
  toString() {
    let t = this.opnds.map((e) => e.toString());
    return (t.length > 3 ? t.slice(3) : t).join("||");
  }
};
function nn(i32) {
  let t = [];
  return i32.values().map(function(e) {
    e instanceof T.PrecedencePredicate && t.push(e);
  }), t;
}
var re = class i10 extends T {
  constructor(t, e, n) {
    super(), this.ruleIndex = t === void 0 ? -1 : t, this.predIndex = e === void 0 ? -1 : e, this.isCtxDependent = n === void 0 ? false : n;
  }
  evaluate(t, e) {
    let n = this.isCtxDependent ? e : null;
    return t.sempred(n, this.ruleIndex, this.predIndex);
  }
  updateHashCode(t) {
    t.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  equals(t) {
    return this === t ? true : t instanceof i10 ? this.ruleIndex === t.ruleIndex && this.predIndex === t.predIndex && this.isCtxDependent === t.isCtxDependent : false;
  }
  toString() {
    return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
  }
};
T.NONE = new re();
var O = class {
  constructor(t) {
    if (t == null)
      throw "target cannot be null.";
    this.target = t, this.isEpsilon = false, this.label = null;
  }
};
var mt = class extends O {
  constructor(t) {
    super(t);
  }
};
var d = { EPSILON: 1, RANGE: 2, RULE: 3, PREDICATE: 4, ATOM: 5, ACTION: 6, SET: 7, NOT_SET: 8, WILDCARD: 9, PRECEDENCE: 10 };
var Vt = class extends mt {
  constructor(t, e, n, s) {
    super(t), this.serializationType = d.PREDICATE, this.ruleIndex = e, this.predIndex = n, this.isCtxDependent = s, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
  getPredicate() {
    return new re(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  toString() {
    return "pred_" + this.ruleIndex + ":" + this.predIndex;
  }
};
var ut = class extends M {
  constructor(t, e, n) {
    super({ message: an(e, n || null), recognizer: t, input: t.inputStream, ctx: t._ctx });
    let r = t.interpreter.atn.states[t.state].transitions[0];
    r instanceof Vt ? (this.ruleIndex = r.ruleIndex, this.predicateIndex = r.predIndex) : (this.ruleIndex = 0, this.predicateIndex = 0), this.predicate = e, this.offendingToken = t.getCurrentToken();
  }
};
function an(i32, t) {
  return t !== null ? t : "failed predicate: {" + i32 + "}?";
}
var J = class extends M {
  constructor(t) {
    super({ message: "", recognizer: t, input: t.inputStream, ctx: t._ctx }), this.offendingToken = t.getCurrentToken();
  }
};
var xt = class extends M {
  constructor(t, e, n, s, r, o) {
    o = o ?? t._ctx, s = s ?? t.getCurrentToken(), n = n ?? t.getCurrentToken(), e = e ?? t.inputStream, super({ message: "", recognizer: t, input: e, ctx: o }), this.deadEndConfigs = r, this.startToken = n, this.offendingToken = s;
  }
};
var _ = class i11 {
  constructor() {
    this.atn = null, this.ruleIndex = 0, this.epsilonOnlyTransitions = false, this.transitions = [], this.nextTokenWithinRule = null;
  }
  get stateType() {
    return i11.INVALID_STATE_NUMBER;
  }
  toString() {
    return `${this.stateNumber}`;
  }
  equals(t) {
    return t instanceof i11 ? this.stateNumber === t.stateNumber : false;
  }
  isNonGreedyExitState() {
    return false;
  }
  addTransition(t, e) {
    e === void 0 && (e = -1), this.transitions.length === 0 ? this.epsilonOnlyTransitions = t.isEpsilon : this.epsilonOnlyTransitions !== t.isEpsilon && (this.epsilonOnlyTransitions = false), e === -1 ? this.transitions.push(t) : this.transitions.splice(e, 1, t);
  }
};
_.INVALID_STATE_NUMBER = -1;
var b = class i12 {
  constructor(t, e, n) {
    this.literalNames = t ?? i12.EMPTY_NAMES, this.symbolicNames = e ?? i12.EMPTY_NAMES, this.displayNames = n ?? i12.EMPTY_NAMES, this.maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
  }
  static fromTokenNames(t) {
    if (t == null || t.length === 0)
      return i12.EMPTY_VOCABULARY;
    let e = [...t], n = [...t];
    for (let s = 0; s < t.length; s++) {
      let r = t[s];
      if (r != null) {
        if (!r.isEmpty()) {
          let o = r.charAt(0);
          if (o === "'") {
            n[s] = null;
            continue;
          } else if (o.toUpperCase() === o) {
            e[s] = null;
            continue;
          }
        }
        e[s] = null, n[s] = null;
      }
    }
    return new i12(e, n, t);
  }
  getMaxTokenType() {
    return this.maxTokenType;
  }
  getLiteralName(t) {
    return t >= 0 && t < this.literalNames.length ? this.literalNames[t] : null;
  }
  getSymbolicName(t) {
    return t >= 0 && t < this.symbolicNames.length ? this.symbolicNames[t] : t === h.EOF ? "EOF" : null;
  }
  getDisplayName(t) {
    if (t >= 0 && t < this.displayNames.length) {
      let s = this.displayNames[t];
      if (s != null)
        return s;
    }
    let e = this.getLiteralName(t);
    if (e != null)
      return e;
    let n = this.getSymbolicName(t);
    return n ?? `${t}`;
  }
  getLiteralNames() {
    return this.literalNames;
  }
  getSymbolicNames() {
    return this.symbolicNames;
  }
  getDisplayNames() {
    return this.displayNames;
  }
};
b.EMPTY_NAMES = [];
b.EMPTY_VOCABULARY = new b(b.EMPTY_NAMES, b.EMPTY_NAMES, b.EMPTY_NAMES);
var D = class i13 {
  static COMPLETE_CHAR_SET = i13.of(N.MIN_CHAR_VALUE, N.MAX_CHAR_VALUE);
  static EMPTY_SET = new i13();
  static {
    i13.COMPLETE_CHAR_SET.readonly = true, i13.EMPTY_SET.readonly = true;
  }
  constructor(t) {
    this.intervals = [], this.readOnly = false, t && this.addSet(t);
  }
  static of(t, e) {
    let n = new i13();
    return n.addRange(t, e), n;
  }
  get minElement() {
    return this.intervals.length === 0 ? h.INVALID_TYPE : this.intervals[0].start;
  }
  get maxElement() {
    return this.intervals.length === 0 ? h.INVALID_TYPE : this.intervals[this.intervals.length - 1].stop;
  }
  get isNil() {
    return this.intervals.length === 0;
  }
  clear() {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    this.intervals = [];
  }
  addOne(t) {
    this.addInterval(new g(t, t));
  }
  addRange(t, e) {
    this.addInterval(new g(t, e));
  }
  addInterval(t) {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    if (this.intervals.length === 0)
      this.intervals.push(t);
    else {
      for (let e = 0; e < this.intervals.length; e++) {
        let n = this.intervals[e];
        if (t.equals(n))
          return;
        if (t.adjacent(n) || !t.disjoint(n)) {
          let s = t.union(n);
          this.intervals[e] = s;
          for (let r = e + 1; r < this.intervals.length; ) {
            let o = this.intervals[r];
            if (!s.adjacent(o) && s.disjoint(o))
              break;
            this.intervals.splice(r, 1), this.intervals[e] = s.union(o);
          }
          return;
        }
        if (t.startsBeforeDisjoint(n)) {
          this.intervals.splice(e, 0, t);
          return;
        }
      }
      this.intervals.push(t);
    }
  }
  addSet(t) {
    return t.intervals.forEach((e) => this.addInterval(e), this), this;
  }
  complement(t, e) {
    if (!t)
      return new i13();
    let n = new i13();
    if (t instanceof i13) {
      if (t.isNil)
        return new i13();
      n.addSet(t);
    } else
      n.addInterval(new g(t, e));
    return n.subtract(this);
  }
  or(t) {
    let e = new i13();
    return e.addSet(this), t.forEach((n) => e.addSet(n), this), e;
  }
  and(t) {
    if (t.isNil)
      return new i13();
    let e = this.intervals, n = t.intervals, s, r = e.length, o = n.length, l = 0, a = 0;
    for (; l < r && a < o; ) {
      let u = e[l], c = n[a];
      u.startsBeforeDisjoint(c) ? l++ : c.startsBeforeDisjoint(u) ? a++ : u.properlyContains(c) ? (s || (s = new i13()), s.addInterval(u.intersection(c)), a++) : c.properlyContains(u) ? (s || (s = new i13()), s.addInterval(u.intersection(c)), l++) : u.disjoint(c) || (s || (s = new i13()), s.addInterval(u.intersection(c)), u.startsAfterNonDisjoint(c) ? a++ : c.startsAfterNonDisjoint(u) && l++);
    }
    return s || new i13();
  }
  subtract(t) {
    if (this.isNil)
      return new i13();
    let e = new i13(this);
    if (t.isNil)
      return e;
    let n = 0, s = 0;
    for (; n < e.intervals.length && s < t.intervals.length; ) {
      let r = e.intervals[n], o = t.intervals[s];
      if (o.stop < r.start) {
        s++;
        continue;
      }
      if (o.start > r.stop) {
        n++;
        continue;
      }
      let l = null, a = null;
      if (o.start > r.start && (l = new g(r.start, o.start - 1)), o.stop < r.stop && (a = new g(o.stop + 1, r.stop)), l != null)
        if (a != null) {
          e.intervals[n] = l, e.intervals.splice(n + 1, 0, a), n++, s++;
          continue;
        } else {
          e.intervals[n] = l, n++;
          continue;
        }
      else if (a != null) {
        e.intervals[n] = a, s++;
        continue;
      } else {
        e.intervals.splice(n, 1);
        continue;
      }
    }
    return e;
  }
  contains(t) {
    if (this.intervals === null)
      return false;
    {
      let e = this.intervals.length, n = 0, s = e - 1;
      for (; n <= s; ) {
        let r = Math.floor((n + s) / 2), o = this.intervals[r];
        if (o.stop < t)
          n = r + 1;
        else if (o.start > t)
          s = r - 1;
        else
          return true;
      }
      return false;
    }
  }
  removeRange(t) {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    if (t.start === t.stop)
      this.removeOne(t.start);
    else if (this.intervals !== null) {
      let e = 0;
      for (let n = 0; n < this.intervals.length; n++) {
        let s = this.intervals[e];
        if (t.stop <= s.start)
          return;
        if (t.start > s.start && t.stop < s.stop) {
          this.intervals[e] = new g(s.start, t.start);
          let r = new g(t.stop, s.stop);
          this.intervals.splice(e, 0, r);
          return;
        } else
          t.start <= s.start && t.stop >= s.stop ? (this.intervals.splice(e, 1), e = e - 1) : t.start < s.stop ? this.intervals[e] = new g(s.start, t.start) : t.stop < s.stop && (this.intervals[e] = new g(t.stop, s.stop));
        e += 1;
      }
    }
  }
  removeOne(t) {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    if (this.intervals !== null)
      for (let e = 0; e < this.intervals.length; e++) {
        let n = this.intervals[e];
        if (t < n.start)
          return;
        if (t === n.start && t === n.stop) {
          this.intervals.splice(e, 1);
          return;
        } else if (t === n.start) {
          this.intervals[e] = new g(n.start + 1, n.stop);
          return;
        } else if (t === n.stop) {
          this.intervals[e] = new g(n.start, n.stop);
          return;
        } else if (t < n.stop) {
          let s = new g(n.start, t);
          n.start = t + 1, this.intervals.splice(e, 0, s);
          return;
        }
      }
  }
  toString(t) {
    if (this.intervals.length === 0)
      return "{}";
    let e = "";
    this.length > 1 && (e += "{");
    let n, s;
    t instanceof b ? (s = t, n = false) : n = t ?? false;
    for (let r = 0; r < this.intervals.length; ++r) {
      let o = this.intervals[r], l = o.start, a = o.stop;
      if (l === a)
        l == h.EOF ? e += "<EOF>" : n ? e += "'" + String.fromCodePoint(l) + "'" : s ? e += this.elementName(s, l) : e += l;
      else if (n)
        e += "'" + String.fromCodePoint(l) + "'..'" + String.fromCodePoint(a) + "'";
      else if (s)
        for (let u = l; u <= a; ++u)
          u > l && (e += ", "), e += this.elementName(s, u);
      else
        e += l + ".." + a;
      r < this.intervals.length - 1 && (e += ", ");
    }
    return this.length > 1 && (e += "}"), e;
  }
  elementName(t, e) {
    return e === h.EOF ? "<EOF>" : e === h.EPSILON ? "<EPSILON>" : t.getDisplayName(e);
  }
  toArray() {
    let t = [];
    if (this.intervals !== null)
      for (let e = 0; e < this.intervals.length; e++) {
        let n = this.intervals[e];
        for (let s = n.start; s <= n.stop; s++)
          t.push(s);
      }
    return t;
  }
  get length() {
    let t = 0;
    if (this.intervals.length == 1) {
      let n = this.intervals[0];
      return n.stop - n.start + 1;
    }
    for (let n of this.intervals)
      t += n.length;
    return t;
  }
  isReadonly() {
    return this.readOnly;
  }
  setReadonly(t) {
    if (this.readOnly && !t)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    this.readOnly = t;
  }
  [Symbol.iterator]() {
    return this.intervals[Symbol.iterator]();
  }
};
var m = { INVALID_TYPE: 0, BASIC: 1, RULE_START: 2, BLOCK_START: 3, PLUS_BLOCK_START: 4, STAR_BLOCK_START: 5, TOKEN_START: 6, RULE_STOP: 7, BLOCK_END: 8, STAR_LOOP_BACK: 9, STAR_LOOP_ENTRY: 10, PLUS_LOOP_BACK: 11, LOOP_END: 12 };
var gt = class {
  constructor() {
    this.errorRecoveryMode = false, this.lastErrorIndex = -1, this.lastErrorStates = null, this.nextTokensContext = null, this.nextTokenState = 0;
  }
  reset(t) {
    this.endErrorCondition(t);
  }
  beginErrorCondition(t) {
    this.errorRecoveryMode = true;
  }
  inErrorRecoveryMode(t) {
    return this.errorRecoveryMode;
  }
  endErrorCondition(t) {
    this.errorRecoveryMode = false, this.lastErrorStates = null, this.lastErrorIndex = -1;
  }
  reportMatch(t) {
    this.endErrorCondition(t);
  }
  reportError(t, e) {
    this.inErrorRecoveryMode(t) || (this.beginErrorCondition(t), e instanceof xt ? this.reportNoViableAlternative(t, e) : e instanceof J ? this.reportInputMismatch(t, e) : e instanceof ut ? this.reportFailedPredicate(t, e) : (console.log("unknown recognition error type: " + e.constructor.name), console.log(e.stack), t.notifyErrorListeners(e.offendingToken, e.getMessage(), e)));
  }
  recover(t, e) {
    this.lastErrorIndex === t.inputStream.index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(t.state) >= 0 && t.consume(), this.lastErrorIndex = t._input.index, this.lastErrorStates === null && (this.lastErrorStates = []), this.lastErrorStates.push(t.state);
    let n = this.getErrorRecoverySet(t);
    this.consumeUntil(t, n);
  }
  sync(t) {
    if (this.inErrorRecoveryMode(t))
      return;
    let e = t.interpreter.atn.states[t.state], n = t.tokenStream.LA(1), s = t.atn.nextTokens(e);
    if (s.contains(n)) {
      this.nextTokensContext = null, this.nextTokenState = _.INVALID_STATE_NUMBER;
      return;
    } else if (s.contains(h.EPSILON)) {
      this.nextTokensContext === null && (this.nextTokensContext = t._ctx, this.nextTokensState = t._stateNumber);
      return;
    }
    switch (e.stateType) {
      case m.BLOCK_START:
      case m.STAR_BLOCK_START:
      case m.PLUS_BLOCK_START:
      case m.STAR_LOOP_ENTRY:
        if (this.singleTokenDeletion(t) !== null)
          return;
        throw new J(t);
      case m.PLUS_LOOP_BACK:
      case m.STAR_LOOP_BACK:
        {
          this.reportUnwantedToken(t);
          let r = new D();
          r.addSet(t.getExpectedTokens());
          let o = r.addSet(this.getErrorRecoverySet(t));
          this.consumeUntil(t, o);
        }
        break;
      default:
    }
  }
  reportNoViableAlternative(t, e) {
    let n = t.tokenStream, s;
    n !== null ? e.startToken.type === h.EOF ? s = "<EOF>" : s = n.getText(new g(e.startToken.tokenIndex, e.offendingToken.tokenIndex)) : s = "<unknown input>";
    let r = "no viable alternative at input " + this.escapeWSAndQuote(s);
    t.notifyErrorListeners(r, e.offendingToken, e);
  }
  reportInputMismatch(t, e) {
    let n = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toString(t.vocabulary);
    t.notifyErrorListeners(n, e.offendingToken, e);
  }
  reportFailedPredicate(t, e) {
    let s = "rule " + t.ruleNames[t._ctx.ruleIndex] + " " + e.message;
    t.notifyErrorListeners(s, e.offendingToken, e);
  }
  reportUnwantedToken(t) {
    if (this.inErrorRecoveryMode(t))
      return;
    this.beginErrorCondition(t);
    let e = t.getCurrentToken(), n = this.getTokenErrorDisplay(e), s = this.getExpectedTokens(t), r = "extraneous input " + n + " expecting " + s.toString(t.vocabulary);
    t.notifyErrorListeners(r, e, null);
  }
  reportMissingToken(t) {
    if (this.inErrorRecoveryMode(t))
      return;
    this.beginErrorCondition(t);
    let e = t.getCurrentToken(), s = "missing " + this.getExpectedTokens(t).toString(t.vocabulary) + " at " + this.getTokenErrorDisplay(e);
    t.notifyErrorListeners(s, e, null);
  }
  recoverInline(t) {
    let e = this.singleTokenDeletion(t);
    if (e !== null)
      return t.consume(), e;
    if (this.singleTokenInsertion(t))
      return this.getMissingSymbol(t);
    throw new J(t);
  }
  singleTokenInsertion(t) {
    let e = t.tokenStream.LA(1), n = t.interpreter.atn, r = n.states[t.state].transitions[0].target;
    return n.nextTokens(r, t._ctx).contains(e) ? (this.reportMissingToken(t), true) : false;
  }
  singleTokenDeletion(t) {
    let e = t.tokenStream.LA(2);
    if (this.getExpectedTokens(t).contains(e)) {
      this.reportUnwantedToken(t), t.consume();
      let s = t.getCurrentToken();
      return this.reportMatch(t), s;
    } else
      return null;
  }
  getMissingSymbol(t) {
    let e = t.getCurrentToken(), n = this.getExpectedTokens(t), s = h.INVALID_TYPE;
    n.isNil || (s = n.minElement);
    let r;
    s === h.EOF ? r = "<missing EOF>" : r = "<missing " + t.vocabulary.getDisplayName(s) + ">";
    let o = e, l = t.tokenStream.LT(-1);
    return o.type === h.EOF && l !== null && (o = l), t.getTokenFactory().create(o.source, s, r, h.DEFAULT_CHANNEL, -1, -1, o.line, o.column);
  }
  getExpectedTokens(t) {
    return t.getExpectedTokens();
  }
  getTokenErrorDisplay(t) {
    if (t === null)
      return "<no token>";
    let e = t.text;
    return e === null && (t.type === h.EOF ? e = "<EOF>" : e = "<" + t.type + ">"), this.escapeWSAndQuote(e);
  }
  escapeWSAndQuote(t) {
    return t = t.replace(/\n/g, "\\n"), t = t.replace(/\r/g, "\\r"), t = t.replace(/\t/g, "\\t"), "'" + t + "'";
  }
  getErrorRecoverySet(t) {
    let e = t.interpreter.atn, n = t._ctx, s = new D();
    for (; n !== null && n.invokingState >= 0; ) {
      let o = e.states[n.invokingState].transitions[0], l = e.nextTokens(o.followState);
      s.addSet(l), n = n.parent;
    }
    return s.removeOne(h.EPSILON), s;
  }
  consumeUntil(t, e) {
    let n = t.tokenStream.LA(1);
    for (; n !== h.EOF && !e.contains(n); )
      t.consume(), n = t.tokenStream.LA(1);
  }
};
function sn(i32, t) {
  if (i32 === null) {
    let e = { state: null, alt: null, context: null, semanticContext: null };
    return t && (e.reachesIntoOuterContext = 0), e;
  } else {
    let e = {};
    return e.state = i32.state || null, e.alt = i32.alt === void 0 ? null : i32.alt, e.context = i32.context || null, e.semanticContext = i32.semanticContext || null, t && (e.reachesIntoOuterContext = i32.reachesIntoOuterContext || 0, e.precedenceFilterSuppressed = i32.precedenceFilterSuppressed || false), e;
  }
}
var C = class i14 {
  constructor(t, e) {
    this.checkContext(t, e), t = sn(t), e = sn(e, true), this.state = t.state !== null ? t.state : e.state, this.alt = t.alt !== null ? t.alt : e.alt, this.context = t.context !== null ? t.context : e.context, this.semanticContext = t.semanticContext !== null ? t.semanticContext : e.semanticContext !== null ? e.semanticContext : T.NONE, this.reachesIntoOuterContext = e.reachesIntoOuterContext, this.precedenceFilterSuppressed = e.precedenceFilterSuppressed;
  }
  checkContext(t, e) {
    (t.context === null || t.context === void 0) && (e === null || e.context === null || e.context === void 0) && (this.context = null);
  }
  hashCode() {
    let t = new R();
    return this.updateHashCode(t), t.finish();
  }
  updateHashCode(t) {
    t.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
  }
  equals(t) {
    return this === t ? true : t instanceof i14 ? this.state.stateNumber === t.state.stateNumber && this.alt === t.alt && (this.context === null ? t.context === null : this.context.equals(t.context)) && this.semanticContext.equals(t.semanticContext) && this.precedenceFilterSuppressed === t.precedenceFilterSuppressed : false;
  }
  hashCodeForConfigSet() {
    let t = new R();
    return t.update(this.state.stateNumber, this.alt, this.semanticContext), t.finish();
  }
  equalsForConfigSet(t) {
    return this === t ? true : t instanceof i14 ? this.state.stateNumber === t.state.stateNumber && this.alt === t.alt && this.semanticContext.equals(t.semanticContext) : false;
  }
  toString() {
    return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== T.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
  }
};
var L = class extends _ {
  get stateType() {
    return m.RULE_STOP;
  }
};
var ht = class extends O {
  constructor(t, e, n, s) {
    super(t), this.ruleIndex = e, this.precedence = n, this.followState = s, this.serializationType = d.RULE, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
};
var Tt = class extends O {
  constructor(t, e) {
    super(t), this.serializationType = d.SET, e != null ? this.label = e : (this.label = new D(), this.label.addOne(h.INVALID_TYPE));
  }
  matches(t, e, n) {
    return this.label.contains(t);
  }
  toString() {
    return this.label.toString();
  }
};
var ot = class extends Tt {
  constructor(t, e) {
    super(t, e), this.serializationType = d.NOT_SET;
  }
  matches(t, e, n) {
    return t >= e && t <= n && !super.matches(t, e, n);
  }
  toString() {
    return "~" + super.toString();
  }
};
var Yt = class extends O {
  constructor(t) {
    super(t), this.serializationType = d.WILDCARD;
  }
  matches(t, e, n) {
    return t >= e && t <= n;
  }
  toString() {
    return ".";
  }
};
function rn(i32, t) {
  return i32 = i32.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r"), t && (i32 = i32.replace(/ /g, "\xB7")), i32;
}
var P = { toStringTree: function(i32, t, e) {
  t = t || null, e = e || null, e !== null && (t = e.ruleNames);
  let n = P.getNodeText(i32, t);
  n = rn(n, false);
  let s = i32.getChildCount();
  if (s === 0)
    return n;
  let r = "(" + n + " ";
  s > 0 && (n = P.toStringTree(i32.getChild(0), t), r = r.concat(n));
  for (let o = 1; o < s; o++)
    n = P.toStringTree(i32.getChild(o), t), r = r.concat(" " + n);
  return r = r.concat(")"), r;
}, getNodeText: function(i32, t, e) {
  if (t = t || null, e = e || null, e !== null && (t = e.ruleNames), t !== null)
    if (i32 instanceof U) {
      let r = i32.ruleContext.getAltNumber();
      return r != 0 ? t[i32.ruleIndex] + ":" + r : t[i32.ruleIndex];
    } else {
      if (i32 instanceof it)
        return i32.toString();
      if (i32 instanceof w && i32.symbol !== null)
        return i32.symbol.text;
    }
  let n = i32.getPayload();
  return n instanceof h ? n.text : i32.getPayload().toString();
}, getChildren: function(i32) {
  let t = [];
  for (let e = 0; e < i32.getChildCount(); e++)
    t.push(i32.getChild(e));
  return t;
}, getAncestors: function(i32) {
  let t = [];
  for (i32 = i32.getParent(); i32 !== null; )
    t = [i32].concat(t), i32 = i32.getParent();
  return t;
}, findAllTokenNodes: function(i32, t) {
  return P.findAllNodes(i32, t, true);
}, findAllRuleNodes: function(i32, t) {
  return P.findAllNodes(i32, t, false);
}, findAllNodes: function(i32, t, e) {
  let n = [];
  return P._findAllNodes(i32, t, e, n), n;
}, _findAllNodes: function(i32, t, e, n) {
  e && i32 instanceof w ? i32.symbol.type === t && n.push(i32) : !e && i32 instanceof U && i32.ruleIndex === t && n.push(i32);
  for (let s = 0; s < i32.getChildCount(); s++)
    P._findAllNodes(i32.getChild(s), t, e, n);
}, descendants: function(i32) {
  let t = [i32];
  for (let e = 0; e < i32.getChildCount(); e++)
    t = t.concat(P.descendants(i32.getChild(e)));
  return t;
} };
var U = class extends Bt {
  constructor(t, e) {
    super(), this._parent = t ?? null, this.children = null, this.invokingState = e ?? -1;
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  depth() {
    let t = 0, e = this;
    for (; e !== null; )
      e = e.parent, t += 1;
    return t;
  }
  isEmpty() {
    return this.invokingState === -1;
  }
  getSourceInterval() {
    return g.INVALID_INTERVAL;
  }
  get ruleContext() {
    return this;
  }
  get ruleIndex() {
    return -1;
  }
  getPayload() {
    return this;
  }
  getText() {
    return this.getChildCount() === 0 ? "" : this.children.map(function(t) {
      return t.getText();
    }).join("");
  }
  getAltNumber() {
    return 0;
  }
  setAltNumber(t) {
  }
  setParent(t) {
    this.parent = t;
  }
  getChild(t) {
    return null;
  }
  getChildCount() {
    return 0;
  }
  accept(t) {
    return t.visitChildren(this);
  }
  toStringTree(t, e) {
    return P.toStringTree(this, t, e);
  }
  toString(t, e) {
    t = t || null, e = e || null;
    let n = this, s = "[";
    for (; n !== null && n !== e; ) {
      if (t === null)
        n.isEmpty() || (s += n.invokingState);
      else {
        let r = n.ruleIndex, o = r >= 0 && r < t.length ? t[r] : "" + r;
        s += o;
      }
      n.parent !== null && (t !== null || !n.parent.isEmpty()) && (s += " "), n = n.parent;
    }
    return s += "]", s;
  }
};
var x = class i15 {
  constructor(t) {
    this.cachedHashCode = t;
  }
  isEmpty() {
    return this === i15.EMPTY;
  }
  hasEmptyPath() {
    return this.getReturnState(this.length - 1) === i15.EMPTY_RETURN_STATE;
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(t) {
    t.update(this.cachedHashCode);
  }
};
x.EMPTY = null;
x.EMPTY_RETURN_STATE = 2147483647;
x.globalNodeCount = 1;
x.id = x.globalNodeCount;
x.trace_atn_sim = false;
var et = class i16 extends x {
  constructor(t, e) {
    let n = new R();
    n.update(t, e);
    let s = n.finish();
    return super(s), this.parents = t, this.returnStates = e, this;
  }
  isEmpty() {
    return this.returnStates[0] === x.EMPTY_RETURN_STATE;
  }
  getParent(t) {
    return this.parents[t];
  }
  getReturnState(t) {
    return this.returnStates[t];
  }
  equals(t) {
    return this === t ? true : t instanceof i16 ? this.hashCode() !== t.hashCode() ? false : pt(this.returnStates, t.returnStates) && pt(this.parents, t.parents) : false;
  }
  toString() {
    if (this.isEmpty())
      return "[]";
    {
      let t = "[";
      for (let e = 0; e < this.returnStates.length; e++) {
        if (e > 0 && (t = t + ", "), this.returnStates[e] === x.EMPTY_RETURN_STATE) {
          t = t + "$";
          continue;
        }
        t = t + this.returnStates[e], this.parents[e] !== null ? t = t + " " + this.parents[e] : t = t + "null";
      }
      return t + "]";
    }
  }
  get length() {
    return this.returnStates.length;
  }
};
var v = class i17 extends x {
  constructor(t, e) {
    let n = 0, s = new R();
    t !== null ? s.update(t, e) : s.update(1), n = s.finish(), super(n), this.parent = t, this.returnState = e;
  }
  getParent(t) {
    return this.parent;
  }
  getReturnState(t) {
    return this.returnState;
  }
  equals(t) {
    return this === t ? true : t instanceof i17 ? this.hashCode() !== t.hashCode() || this.returnState !== t.returnState ? false : this.parent == null ? t.parent == null : this.parent.equals(t.parent) : false;
  }
  toString() {
    let t = this.parent === null ? "" : this.parent.toString();
    return t.length === 0 ? this.returnState === x.EMPTY_RETURN_STATE ? "$" : "" + this.returnState : "" + this.returnState + " " + t;
  }
  get length() {
    return 1;
  }
  static create(t, e) {
    return e === x.EMPTY_RETURN_STATE && t === null ? x.EMPTY : new i17(t, e);
  }
};
var qt = class extends v {
  constructor() {
    super(null, x.EMPTY_RETURN_STATE);
  }
  isEmpty() {
    return true;
  }
  getParent(t) {
    return null;
  }
  getReturnState(t) {
    return this.returnState;
  }
  equals(t) {
    return this === t;
  }
  toString() {
    return "$";
  }
};
x.EMPTY = new qt();
var ie = "h-";
var Q = class {
  constructor(t, e) {
    this.data = {}, this.hashFunction = t || Te, this.equalsFunction = e || Se;
  }
  set(t, e) {
    let n = ie + this.hashFunction(t);
    if (n in this.data) {
      let s = this.data[n];
      for (let r = 0; r < s.length; r++) {
        let o = s[r];
        if (this.equalsFunction(t, o.key)) {
          let l = o.value;
          return o.value = e, l;
        }
      }
      return s.push({ key: t, value: e }), e;
    } else
      return this.data[n] = [{ key: t, value: e }], e;
  }
  containsKey(t) {
    let e = ie + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++) {
        let r = n[s];
        if (this.equalsFunction(t, r.key))
          return true;
      }
    }
    return false;
  }
  get(t) {
    let e = ie + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++) {
        let r = n[s];
        if (this.equalsFunction(t, r.key))
          return r.value;
      }
    }
    return null;
  }
  entries() {
    return Object.keys(this.data).filter((t) => t.startsWith(ie)).flatMap((t) => this.data[t], this);
  }
  getKeys() {
    return this.entries().map((t) => t.key);
  }
  getValues() {
    return this.entries().map((t) => t.value);
  }
  toString() {
    return "[" + this.entries().map((e) => "{" + e.key + ":" + e.value + "}").join(", ") + "]";
  }
  get length() {
    return Object.keys(this.data).filter((t) => t.startsWith(ie)).map((t) => this.data[t].length, this).reduce((t, e) => t + e, 0);
  }
};
function oe(i32, t) {
  if (t == null && (t = U.EMPTY), t.parent === null || t === U.EMPTY)
    return x.EMPTY;
  let e = oe(i32, t.parent), s = i32.states[t.invokingState].transitions[0];
  return v.create(e, s.followState.stateNumber);
}
function Qe(i32, t, e) {
  if (i32.isEmpty())
    return i32;
  let n = e.get(i32) || null;
  if (n !== null)
    return n;
  if (n = t.get(i32), n !== null)
    return e.set(i32, n), n;
  let s = false, r = [];
  for (let l = 0; l < r.length; l++) {
    let a = Qe(i32.getParent(l), t, e);
    if (s || a !== i32.getParent(l)) {
      if (!s) {
        r = [];
        for (let u = 0; u < i32.length; u++)
          r[u] = i32.getParent(u);
        s = true;
      }
      r[l] = a;
    }
  }
  if (!s)
    return t.add(i32), e.set(i32, i32), i32;
  let o = null;
  return r.length === 0 ? o = x.EMPTY : r.length === 1 ? o = v.create(r[0], i32.getReturnState(0)) : o = new et(r, i32.returnStates), t.add(o), e.set(o, o), e.set(i32, o), o;
}
function Ae(i32, t, e, n) {
  if (i32 === t)
    return i32;
  if (i32 instanceof v && t instanceof v)
    return cn(i32, t, e, n);
  if (e) {
    if (i32 instanceof qt)
      return i32;
    if (t instanceof qt)
      return t;
  }
  return i32 instanceof v && (i32 = new et([i32.getParent()], [i32.returnState])), t instanceof v && (t = new et([t.getParent()], [t.returnState])), un(i32, t, e, n);
}
function un(i32, t, e, n) {
  if (n !== null) {
    let c = n.get(i32, t);
    if (c !== null)
      return x.trace_atn_sim && console.log("mergeArrays a=" + i32 + ",b=" + t + " -> previous"), c;
    if (c = n.get(t, i32), c !== null)
      return x.trace_atn_sim && console.log("mergeArrays a=" + i32 + ",b=" + t + " -> previous"), c;
  }
  let s = 0, r = 0, o = 0, l = new Array(i32.returnStates.length + t.returnStates.length).fill(0), a = new Array(i32.returnStates.length + t.returnStates.length).fill(null);
  for (; s < i32.returnStates.length && r < t.returnStates.length; ) {
    let c = i32.parents[s], f = t.parents[r];
    if (i32.returnStates[s] === t.returnStates[r]) {
      let p = i32.returnStates[s];
      p === x.EMPTY_RETURN_STATE && c === null && f === null || c !== null && f !== null && c === f ? (a[o] = c, l[o] = p) : (a[o] = Ae(c, f, e, n), l[o] = p), s += 1, r += 1;
    } else
      i32.returnStates[s] < t.returnStates[r] ? (a[o] = c, l[o] = i32.returnStates[s], s += 1) : (a[o] = f, l[o] = t.returnStates[r], r += 1);
    o += 1;
  }
  if (s < i32.returnStates.length)
    for (let c = s; c < i32.returnStates.length; c++)
      a[o] = i32.parents[c], l[o] = i32.returnStates[c], o += 1;
  else
    for (let c = r; c < t.returnStates.length; c++)
      a[o] = t.parents[c], l[o] = t.returnStates[c], o += 1;
  if (o < a.length) {
    if (o === 1) {
      let c = v.create(a[0], l[0]);
      return n !== null && n.set(i32, t, c), c;
    }
    a = a.slice(0, o), l = l.slice(0, o);
  }
  let u = new et(a, l);
  return u.equals(i32) ? (n !== null && n.set(i32, t, i32), x.trace_atn_sim && console.log("mergeArrays a=" + i32 + ",b=" + t + " -> a"), i32) : u.equals(t) ? (n !== null && n.set(i32, t, t), x.trace_atn_sim && console.log("mergeArrays a=" + i32 + ",b=" + t + " -> b"), t) : (hn(a), n !== null && n.set(i32, t, u), x.trace_atn_sim && console.log("mergeArrays a=" + i32 + ",b=" + t + " -> " + u), u);
}
function hn(i32) {
  let t = new Q();
  for (let e = 0; e < i32.length; e++) {
    let n = i32[e];
    t.containsKey(n) || t.set(n, n);
  }
  for (let e = 0; e < i32.length; e++)
    i32[e] = t.get(i32[e]);
}
function cn(i32, t, e, n) {
  if (n !== null) {
    let r = n.get(i32, t);
    if (r !== null || (r = n.get(t, i32), r !== null))
      return r;
  }
  let s = fn(i32, t, e);
  if (s !== null)
    return n !== null && n.set(i32, t, s), s;
  if (i32.returnState === t.returnState) {
    let r = Ae(i32.parent, t.parent, e, n);
    if (r === i32.parent)
      return i32;
    if (r === t.parent)
      return t;
    let o = v.create(r, i32.returnState);
    return n !== null && n.set(i32, t, o), o;
  } else {
    let r = null;
    if ((i32 === t || i32.parent !== null && i32.parent === t.parent) && (r = i32.parent), r !== null) {
      let u = [i32.returnState, t.returnState];
      i32.returnState > t.returnState && (u[0] = t.returnState, u[1] = i32.returnState);
      let c = [r, r], f = new et(c, u);
      return n !== null && n.set(i32, t, f), f;
    }
    let o = [i32.returnState, t.returnState], l = [i32.parent, t.parent];
    i32.returnState > t.returnState && (o[0] = t.returnState, o[1] = i32.returnState, l = [t.parent, i32.parent]);
    let a = new et(l, o);
    return n !== null && n.set(i32, t, a), a;
  }
}
function fn(i32, t, e) {
  if (e) {
    if (i32 === x.EMPTY)
      return x.EMPTY;
    if (t === x.EMPTY)
      return x.EMPTY;
  } else {
    if (i32 === x.EMPTY && t === x.EMPTY)
      return x.EMPTY;
    if (i32 === x.EMPTY) {
      let n = [t.returnState, x.EMPTY_RETURN_STATE], s = [t.parent, null];
      return new et(s, n);
    } else if (t === x.EMPTY) {
      let n = [i32.returnState, x.EMPTY_RETURN_STATE], s = [i32.parent, null];
      return new et(s, n);
    }
  }
  return null;
}
var H = class {
  constructor() {
    this.data = [];
  }
  clear(t) {
    t === void 0 ? this.data = [] : (this.resize(t), this.data[t >>> 5] &= ~(1 << t));
  }
  or(t) {
    let e = Math.min(this.data.length, t.data.length), n = 0;
    for (; n + 7 < e; n += 8)
      this.data[n] |= t.data[n], this.data[n + 1] |= t.data[n + 1], this.data[n + 2] |= t.data[n + 2], this.data[n + 3] |= t.data[n + 3], this.data[n + 4] |= t.data[n + 4], this.data[n + 5] |= t.data[n + 5], this.data[n + 6] |= t.data[n + 6], this.data[n + 7] |= t.data[n + 7];
    for (; n < e; ++n)
      this.data[n] |= t.data[n];
    if (this.data.length < t.data.length) {
      this.resize((t.data.length << 5) - 1);
      let s = t.data.length;
      for (let r = e; r < s; ++r)
        this.data[r] = t.data[r];
    }
  }
  get(t) {
    return (this.data[t >>> 5] & 1 << t) !== 0;
  }
  get length() {
    let t = 0, e = this.data.length, n = this.data;
    for (let s = 0; s < e; s++)
      t += this.bitCount(n[s]);
    return t;
  }
  values() {
    let t = new Array(this.length()), e = 0, n = this.data.length;
    for (let s = 0; s < n; ++s) {
      let r = this.data[s];
      for (; r != 0; ) {
        let o = r & -r;
        t[e++] = (s << 5) + this.bitCount(o - 1 | 0), r ^= o;
      }
    }
    return t;
  }
  nextSetBit(t) {
    for (let e of this)
      if (e > t)
        return e;
  }
  set(t) {
    this.resize(t), this.data[t >>> 5] |= 1 << t;
  }
  toString() {
    return "{" + this.values().join(", ") + "}";
  }
  resize(t) {
    let e = t + 32 >>> 5;
    for (let n = this.data.length; n < e; n++)
      this.data[n] = 0;
  }
  bitCount(t) {
    return t -= t >>> 1 & 1431655765, t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24;
  }
  [Symbol.iterator]() {
    let t = this.data.length, e = 0, n = this.data[e], s = this.bitCount, r = this.data;
    return { [Symbol.iterator]() {
      return this;
    }, next() {
      for (; e < t; )
        if (n !== 0) {
          let o = n & -n, l = (e << 5) + s(o - 1 | 0);
          return n ^= o, { done: false, value: l };
        } else
          e++, e < t && (n = r[e]);
      return { done: true, value: void 0 };
    } };
  }
};
var Rt = class i18 {
  constructor(t) {
    this.atn = t;
  }
  getDecisionLookahead(t) {
    if (t === null)
      return null;
    let e = t.transitions.length, n = [];
    for (let s = 0; s < e; s++) {
      n[s] = new D();
      let r = new k(), o = false;
      this._LOOK(t.transition(s).target, null, x.EMPTY, n[s], r, new H(), o, false), (n[s].length === 0 || n[s].contains(i18.HIT_PRED)) && (n[s] = null);
    }
    return n;
  }
  LOOK(t, e, n) {
    let s = new D(), r = true;
    n = n || null;
    let o = n !== null ? oe(t.atn, n) : null;
    return this._LOOK(t, e, o, s, new k(), new H(), r, true), s;
  }
  _LOOK(t, e, n, s, r, o, l, a) {
    let u = new C({ state: t, alt: 0, context: n }, null);
    if (!r.has(u)) {
      if (r.add(u), t === e) {
        if (n === null) {
          s.addOne(h.EPSILON);
          return;
        } else if (n.isEmpty() && a) {
          s.addOne(h.EOF);
          return;
        }
      }
      if (t instanceof L) {
        if (n === null) {
          s.addOne(h.EPSILON);
          return;
        } else if (n.isEmpty() && a) {
          s.addOne(h.EOF);
          return;
        }
        if (n !== x.EMPTY) {
          let c = o.get(t.ruleIndex);
          try {
            o.clear(t.ruleIndex);
            for (let f = 0; f < n.length; f++) {
              let p = this.atn.states[n.getReturnState(f)];
              this._LOOK(p, e, n.getParent(f), s, r, o, l, a);
            }
          } finally {
            c && o.set(t.ruleIndex);
          }
          return;
        }
      }
      for (let c = 0; c < t.transitions.length; c++) {
        let f = t.transitions[c];
        if (f.constructor === ht) {
          if (o.get(f.target.ruleIndex))
            continue;
          let p = v.create(n, f.followState.stateNumber);
          try {
            o.set(f.target.ruleIndex), this._LOOK(f.target, e, p, s, r, o, l, a);
          } finally {
            o.clear(f.target.ruleIndex);
          }
        } else if (f instanceof mt)
          l ? this._LOOK(f.target, e, n, s, r, o, l, a) : s.addOne(i18.HIT_PRED);
        else if (f.isEpsilon)
          this._LOOK(f.target, e, n, s, r, o, l, a);
        else if (f.constructor === Yt)
          s.addRange(h.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
        else {
          let p = f.label;
          p !== null && (f instanceof ot && (p = p.complement(h.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)), s.addSet(p));
        }
      }
    }
  }
};
Rt.HIT_PRED = h.INVALID_TYPE;
var S = class {
  constructor(t, e) {
    this.grammarType = t, this.maxTokenType = e, this.states = [], this.decisionToState = [], this.ruleToStartState = [], this.ruleToStopState = [], this.modeNameToStartState = {}, this.ruleToTokenType = [], this.lexerActions = [], this.modeToStartState = [];
  }
  nextTokensInContext(t, e) {
    return new Rt(this).LOOK(t, null, e);
  }
  nextTokensNoContext(t) {
    return t.nextTokenWithinRule !== null || (t.nextTokenWithinRule = this.nextTokensInContext(t, null), t.nextTokenWithinRule.readOnly = true), t.nextTokenWithinRule;
  }
  nextTokens(t, e) {
    return e === void 0 ? this.nextTokensNoContext(t) : this.nextTokensInContext(t, e);
  }
  addState(t) {
    t !== null && (t.atn = this, t.stateNumber = this.states.length), this.states.push(t);
  }
  removeState(t) {
    this.states[t.stateNumber] = null;
  }
  defineDecisionState(t) {
    return this.decisionToState.push(t), t.decision = this.decisionToState.length - 1, t.decision;
  }
  getDecisionState(t) {
    return this.decisionToState.length === 0 ? null : this.decisionToState[t];
  }
  getExpectedTokens(t, e) {
    if (t < 0 || t >= this.states.length)
      throw "Invalid state number.";
    let n = this.states[t], s = this.nextTokens(n);
    if (!s.contains(h.EPSILON))
      return s;
    let r = new D();
    for (r.addSet(s), r.removeOne(h.EPSILON); e !== null && e.invokingState >= 0 && s.contains(h.EPSILON); ) {
      let l = this.states[e.invokingState].transitions[0];
      s = this.nextTokens(l.followState), r.addSet(s), r.removeOne(h.EPSILON), e = e.parent;
    }
    return s.contains(h.EPSILON) && r.addOne(h.EOF), r;
  }
};
S.INVALID_ALT_NUMBER = 0;
var wt = { LEXER: 0, PARSER: 1 };
var Ot = class extends _ {
  get stateType() {
    return m.BASIC;
  }
};
var B = class extends _ {
  constructor() {
    return super(), this.decision = -1, this.nonGreedy = false, this;
  }
};
var q = class extends B {
  constructor() {
    return super(), this.endState = null, this;
  }
};
var Kt = class extends _ {
  get stateType() {
    return m.BLOCK_END;
  }
};
var W = class extends _ {
  get stateType() {
    return m.LOOP_END;
  }
};
var le = class extends _ {
  constructor() {
    super(), this.isPrecedenceRule = false;
  }
  get stateType() {
    return m.RULE_START;
  }
};
var jt = class extends B {
  get stateType() {
    return m.TOKEN_START;
  }
};
var Dt = class extends B {
  get stateType() {
    return m.PLUS_LOOP_BACK;
  }
};
var St = class extends _ {
  get stateType() {
    return m.STAR_LOOP_BACK;
  }
};
var Y = class extends B {
  constructor() {
    super(), this.precedenceRuleDecision = false;
  }
  get stateType() {
    return m.STAR_LOOP_ENTRY;
  }
};
var Et = class extends q {
  get stateType() {
    return m.PLUS_BLOCK_START;
  }
};
var At = class extends q {
  get stateType() {
    return m.STAR_BLOCK_START;
  }
};
var ae = class extends q {
  get stateType() {
    return m.BLOCK_START;
  }
};
var Nt = class extends O {
  constructor(t, e) {
    super(t), this.label_ = e, this.label = this.makeLabel(), this.serializationType = d.ATOM;
  }
  makeLabel() {
    let t = new D();
    return t.addOne(this.label_), t;
  }
  matches(t, e, n) {
    return this.label_ === t;
  }
  toString() {
    return this.label_;
  }
};
var ue = class extends O {
  constructor(t, e, n) {
    super(t), this.serializationType = d.RANGE, this.start = e, this.stop = n, this.label = this.makeLabel();
  }
  makeLabel() {
    let t = new D();
    return t.addRange(this.start, this.stop), t;
  }
  matches(t, e, n) {
    return t >= this.start && t <= this.stop;
  }
  toString() {
    return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
  }
};
var Gt = class extends O {
  constructor(t, e, n, s) {
    super(t), this.serializationType = d.ACTION, this.ruleIndex = e, this.actionIndex = n === void 0 ? -1 : n, this.isCtxDependent = s === void 0 ? false : s, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
  toString() {
    return "action_" + this.ruleIndex + ":" + this.actionIndex;
  }
};
var Ct = class extends O {
  constructor(t, e) {
    super(t), this.serializationType = d.EPSILON, this.isEpsilon = true, this.outermostPrecedenceReturn = e;
  }
  matches(t, e, n) {
    return false;
  }
  toString() {
    return "epsilon";
  }
};
var he = class i19 extends T {
  constructor(t) {
    super(), this.precedence = t === void 0 ? 0 : t;
  }
  evaluate(t, e) {
    return t.precpred(e, this.precedence);
  }
  evalPrecedence(t, e) {
    return t.precpred(e, this.precedence) ? T.NONE : null;
  }
  compareTo(t) {
    return this.precedence - t.precedence;
  }
  updateHashCode(t) {
    t.update(this.precedence);
  }
  equals(t) {
    return this === t ? true : t instanceof i19 ? this.precedence === t.precedence : false;
  }
  toString() {
    return "{" + this.precedence + ">=prec}?";
  }
};
T.PrecedencePredicate = he;
var Ne = class extends mt {
  constructor(t, e) {
    super(t), this.serializationType = d.PRECEDENCE, this.precedence = e, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
  getPredicate() {
    return new he(this.precedence);
  }
  toString() {
    return this.precedence + " >= _p";
  }
};
var ct = class {
  constructor(t) {
    t === void 0 && (t = null), this.readOnly = false, this.verifyATN = t === null ? true : t.verifyATN, this.generateRuleBypassTransitions = t === null ? false : t.generateRuleBypassTransitions;
  }
};
ct.defaultOptions = new ct();
ct.defaultOptions.readOnly = true;
var y = { CHANNEL: 0, CUSTOM: 1, MODE: 2, MORE: 3, POP_MODE: 4, PUSH_MODE: 5, SKIP: 6, TYPE: 7 };
var F = class {
  constructor(t) {
    this.actionType = t, this.isPositionDependent = false;
  }
  hashCode() {
    let t = new R();
    return this.updateHashCode(t), t.finish();
  }
  updateHashCode(t) {
    t.update(this.actionType);
  }
  equals(t) {
    return this === t;
  }
};
var Wt = class extends F {
  constructor() {
    super(y.SKIP);
  }
  execute(t) {
    t.skip();
  }
  toString() {
    return "skip";
  }
};
Wt.INSTANCE = new Wt();
var Ce = class i20 extends F {
  constructor(t) {
    super(y.CHANNEL), this.channel = t;
  }
  execute(t) {
    t._channel = this.channel;
  }
  updateHashCode(t) {
    t.update(this.actionType, this.channel);
  }
  equals(t) {
    return this === t ? true : t instanceof i20 ? this.channel === t.channel : false;
  }
  toString() {
    return "channel(" + this.channel + ")";
  }
};
var ye = class i21 extends F {
  constructor(t, e) {
    super(y.CUSTOM), this.ruleIndex = t, this.actionIndex = e, this.isPositionDependent = true;
  }
  execute(t) {
    t.action(null, this.ruleIndex, this.actionIndex);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.ruleIndex, this.actionIndex);
  }
  equals(t) {
    return this === t ? true : t instanceof i21 ? this.ruleIndex === t.ruleIndex && this.actionIndex === t.actionIndex : false;
  }
};
var Xt = class extends F {
  constructor() {
    super(y.MORE);
  }
  execute(t) {
    t.more();
  }
  toString() {
    return "more";
  }
};
Xt.INSTANCE = new Xt();
var _e = class i22 extends F {
  constructor(t) {
    super(y.TYPE), this.type = t;
  }
  execute(t) {
    t.type = this.type;
  }
  updateHashCode(t) {
    t.update(this.actionType, this.type);
  }
  equals(t) {
    return this === t ? true : t instanceof i22 ? this.type === t.type : false;
  }
  toString() {
    return "type(" + this.type + ")";
  }
};
var Ie = class i23 extends F {
  constructor(t) {
    super(y.PUSH_MODE), this.mode = t;
  }
  execute(t) {
    t.pushMode(this.mode);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.mode);
  }
  equals(t) {
    return this === t ? true : t instanceof i23 ? this.mode === t.mode : false;
  }
  toString() {
    return "pushMode(" + this.mode + ")";
  }
};
var zt = class extends F {
  constructor() {
    super(y.POP_MODE);
  }
  execute(t) {
    t.popMode();
  }
  toString() {
    return "popMode";
  }
};
zt.INSTANCE = new zt();
var ke = class i24 extends F {
  constructor(t) {
    super(y.MODE), this.mode = t;
  }
  execute(t) {
    t.mode(this.mode);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.mode);
  }
  equals(t) {
    return this === t ? true : t instanceof i24 ? this.mode === t.mode : false;
  }
  toString() {
    return "mode(" + this.mode + ")";
  }
};
var Ze = 4;
function Le(i32, t) {
  let e = [];
  return e[i32 - 1] = t, e.map(function(n) {
    return t;
  });
}
var yt = class {
  constructor(t) {
    t == null && (t = ct.defaultOptions), this.deserializationOptions = t, this.stateFactories = null, this.actionFactories = null;
  }
  deserialize(t) {
    let e = this.reset(t);
    this.checkVersion(e), e && this.skipUUID();
    let n = this.readATN();
    this.readStates(n, e), this.readRules(n, e), this.readModes(n);
    let s = [];
    return this.readSets(n, s, this.readInt.bind(this)), e && this.readSets(n, s, this.readInt32.bind(this)), this.readEdges(n, s), this.readDecisions(n), this.readLexerActions(n, e), this.markPrecedenceDecisions(n), this.verifyATN(n), this.deserializationOptions.generateRuleBypassTransitions && n.grammarType === wt.PARSER && (this.generateRuleBypassTransitions(n), this.verifyATN(n)), n;
  }
  reset(t) {
    if ((t.charCodeAt ? t.charCodeAt(0) : t[0]) === Ze - 1) {
      let n = function(r) {
        let o = r.charCodeAt(0);
        return o > 1 ? o - 2 : o + 65534;
      }, s = t.split("").map(n);
      return s[0] = t.charCodeAt(0), this.data = s, this.pos = 0, true;
    } else
      return this.data = t, this.pos = 0, false;
  }
  skipUUID() {
    let t = 0;
    for (; t++ < 8; )
      this.readInt();
  }
  checkVersion(t) {
    let e = this.readInt();
    if (!t && e !== Ze)
      throw "Could not deserialize ATN with version " + e + " (expected " + Ze + ").";
  }
  readATN() {
    let t = this.readInt(), e = this.readInt();
    return new S(t, e);
  }
  readStates(t, e) {
    let n, s, r, o = [], l = [], a = this.readInt();
    for (let f = 0; f < a; f++) {
      let p = this.readInt();
      if (p === m.INVALID_TYPE) {
        t.addState(null);
        continue;
      }
      let E = this.readInt();
      e && E === 65535 && (E = -1);
      let tt = this.stateFactory(p, E);
      if (p === m.LOOP_END) {
        let kt = this.readInt();
        o.push([tt, kt]);
      } else if (tt instanceof q) {
        let kt = this.readInt();
        l.push([tt, kt]);
      }
      t.addState(tt);
    }
    for (n = 0; n < o.length; n++)
      s = o[n], s[0].loopBackState = t.states[s[1]];
    for (n = 0; n < l.length; n++)
      s = l[n], s[0].endState = t.states[s[1]];
    let u = this.readInt();
    for (n = 0; n < u; n++)
      r = this.readInt(), t.states[r].nonGreedy = true;
    let c = this.readInt();
    for (n = 0; n < c; n++)
      r = this.readInt(), t.states[r].isPrecedenceRule = true;
  }
  readRules(t, e) {
    let n, s = this.readInt();
    for (t.grammarType === wt.LEXER && (t.ruleToTokenType = Le(s, 0)), t.ruleToStartState = Le(s, 0), n = 0; n < s; n++) {
      let r = this.readInt();
      if (t.ruleToStartState[n] = t.states[r], t.grammarType === wt.LEXER) {
        let o = this.readInt();
        e && o === 65535 && (o = h.EOF), t.ruleToTokenType[n] = o;
      }
    }
    for (t.ruleToStopState = Le(s, 0), n = 0; n < t.states.length; n++) {
      let r = t.states[n];
      r instanceof L && (t.ruleToStopState[r.ruleIndex] = r, t.ruleToStartState[r.ruleIndex].stopState = r);
    }
  }
  readModes(t) {
    let e = this.readInt();
    for (let n = 0; n < e; n++) {
      let s = this.readInt();
      t.modeToStartState.push(t.states[s]);
    }
  }
  readSets(t, e, n) {
    let s = this.readInt();
    for (let r = 0; r < s; r++) {
      let o = new D();
      e.push(o);
      let l = this.readInt();
      this.readInt() !== 0 && o.addOne(-1);
      for (let u = 0; u < l; u++) {
        let c = n(), f = n();
        o.addRange(c, f);
      }
    }
  }
  readEdges(t, e) {
    let n, s, r, o, l, a = this.readInt();
    for (n = 0; n < a; n++) {
      let u = this.readInt(), c = this.readInt(), f = this.readInt(), p = this.readInt(), E = this.readInt(), tt = this.readInt();
      o = this.edgeFactory(t, f, u, c, p, E, tt, e), t.states[u].addTransition(o);
    }
    for (n = 0; n < t.states.length; n++)
      for (r = t.states[n], s = 0; s < r.transitions.length; s++) {
        let u = r.transitions[s];
        if (!(u instanceof ht))
          continue;
        let c = -1;
        t.ruleToStartState[u.target.ruleIndex].isPrecedenceRule && u.precedence === 0 && (c = u.target.ruleIndex), o = new Ct(u.followState, c), t.ruleToStopState[u.target.ruleIndex].addTransition(o);
      }
    for (n = 0; n < t.states.length; n++) {
      if (r = t.states[n], r instanceof q) {
        if (r.endState === null || r.endState.startState)
          throw "IllegalState";
        r.endState.startState = r;
      }
      if (r instanceof Dt)
        for (s = 0; s < r.transitions.length; s++)
          l = r.transitions[s].target, l instanceof Et && (l.loopBackState = r);
      else if (r instanceof St)
        for (s = 0; s < r.transitions.length; s++)
          l = r.transitions[s].target, l instanceof Y && (l.loopBackState = r);
    }
  }
  readDecisions(t) {
    let e = this.readInt();
    for (let n = 0; n < e; n++) {
      let s = this.readInt(), r = t.states[s];
      t.decisionToState.push(r), r.decision = n;
    }
  }
  readLexerActions(t, e) {
    if (t.grammarType === wt.LEXER) {
      let n = this.readInt();
      t.lexerActions = Le(n, null);
      for (let s = 0; s < n; s++) {
        let r = this.readInt(), o = this.readInt();
        e && o === 65535 && (o = -1);
        let l = this.readInt();
        e && l === 65535 && (l = -1), t.lexerActions[s] = this.lexerActionFactory(r, o, l);
      }
    }
  }
  generateRuleBypassTransitions(t) {
    let e, n = t.ruleToStartState.length;
    for (e = 0; e < n; e++)
      t.ruleToTokenType[e] = t.maxTokenType + e + 1;
    for (e = 0; e < n; e++)
      this.generateRuleBypassTransition(t, e);
  }
  generateRuleBypassTransition(t, e) {
    let n, s, r = new ae();
    r.ruleIndex = e, t.addState(r);
    let o = new Kt();
    o.ruleIndex = e, t.addState(o), r.endState = o, t.defineDecisionState(r), o.startState = r;
    let l = null, a = null;
    if (t.ruleToStartState[e].isPrecedenceRule) {
      for (a = null, n = 0; n < t.states.length; n++)
        if (s = t.states[n], this.stateIsEndStateFor(s, e)) {
          a = s, l = s.loopBackState.transitions[0];
          break;
        }
      if (l === null)
        throw "Couldn't identify final state of the precedence rule prefix section.";
    } else
      a = t.ruleToStopState[e];
    for (n = 0; n < t.states.length; n++) {
      s = t.states[n];
      for (let p = 0; p < s.transitions.length; p++) {
        let E = s.transitions[p];
        E !== l && E.target === a && (E.target = o);
      }
    }
    let u = t.ruleToStartState[e], c = u.transitions.length;
    for (; c > 0; )
      r.addTransition(u.transitions[c - 1]), u.transitions = u.transitions.slice(-1);
    t.ruleToStartState[e].addTransition(new Ct(r)), o.addTransition(new Ct(a));
    let f = new Ot();
    t.addState(f), f.addTransition(new Nt(o, t.ruleToTokenType[e])), r.addTransition(new Ct(f));
  }
  stateIsEndStateFor(t, e) {
    if (t.ruleIndex !== e || !(t instanceof Y))
      return null;
    let n = t.transitions[t.transitions.length - 1].target;
    return n instanceof W && n.epsilonOnlyTransitions && n.transitions[0].target instanceof L ? t : null;
  }
  markPrecedenceDecisions(t) {
    for (let e = 0; e < t.states.length; e++) {
      let n = t.states[e];
      if (n instanceof Y && t.ruleToStartState[n.ruleIndex].isPrecedenceRule) {
        let s = n.transitions[n.transitions.length - 1].target;
        s instanceof W && s.epsilonOnlyTransitions && s.transitions[0].target instanceof L && (n.precedenceRuleDecision = true);
      }
    }
  }
  verifyATN(t) {
    if (this.deserializationOptions.verifyATN)
      for (let e = 0; e < t.states.length; e++) {
        let n = t.states[e];
        if (n !== null)
          if (this.checkCondition(n.epsilonOnlyTransitions || n.transitions.length <= 1), n instanceof Et)
            this.checkCondition(n.loopBackState !== null);
          else if (n instanceof Y)
            if (this.checkCondition(n.loopBackState !== null), this.checkCondition(n.transitions.length === 2), n.transitions[0].target instanceof At)
              this.checkCondition(n.transitions[1].target instanceof W), this.checkCondition(!n.nonGreedy);
            else if (n.transitions[0].target instanceof W)
              this.checkCondition(n.transitions[1].target instanceof At), this.checkCondition(n.nonGreedy);
            else
              throw "IllegalState";
          else
            n instanceof St ? (this.checkCondition(n.transitions.length === 1), this.checkCondition(n.transitions[0].target instanceof Y)) : n instanceof W ? this.checkCondition(n.loopBackState !== null) : n instanceof le ? this.checkCondition(n.stopState !== null) : n instanceof q ? this.checkCondition(n.endState !== null) : n instanceof Kt ? this.checkCondition(n.startState !== null) : n instanceof B ? this.checkCondition(n.transitions.length <= 1 || n.decision >= 0) : this.checkCondition(n.transitions.length <= 1 || n instanceof L);
      }
  }
  checkCondition(t, e) {
    if (!t)
      throw e == null && (e = "IllegalState"), e;
  }
  readInt() {
    return this.data[this.pos++];
  }
  readInt32() {
    let t = this.readInt(), e = this.readInt();
    return t | e << 16;
  }
  edgeFactory(t, e, n, s, r, o, l, a) {
    let u = t.states[s];
    switch (e) {
      case d.EPSILON:
        return new Ct(u);
      case d.RANGE:
        return l !== 0 ? new ue(u, h.EOF, o) : new ue(u, r, o);
      case d.RULE:
        return new ht(t.states[r], o, l, u);
      case d.PREDICATE:
        return new Vt(u, r, o, l !== 0);
      case d.PRECEDENCE:
        return new Ne(u, r);
      case d.ATOM:
        return l !== 0 ? new Nt(u, h.EOF) : new Nt(u, r);
      case d.ACTION:
        return new Gt(u, r, o, l !== 0);
      case d.SET:
        return new Tt(u, a[r]);
      case d.NOT_SET:
        return new ot(u, a[r]);
      case d.WILDCARD:
        return new Yt(u);
      default:
        throw "The specified transition type: " + e + " is not valid.";
    }
  }
  stateFactory(t, e) {
    if (this.stateFactories === null) {
      let n = [];
      n[m.INVALID_TYPE] = null, n[m.BASIC] = () => new Ot(), n[m.RULE_START] = () => new le(), n[m.BLOCK_START] = () => new ae(), n[m.PLUS_BLOCK_START] = () => new Et(), n[m.STAR_BLOCK_START] = () => new At(), n[m.TOKEN_START] = () => new jt(), n[m.RULE_STOP] = () => new L(), n[m.BLOCK_END] = () => new Kt(), n[m.STAR_LOOP_BACK] = () => new St(), n[m.STAR_LOOP_ENTRY] = () => new Y(), n[m.PLUS_LOOP_BACK] = () => new Dt(), n[m.LOOP_END] = () => new W(), this.stateFactories = n;
    }
    if (t > this.stateFactories.length || this.stateFactories[t] === null)
      throw "The specified state type " + t + " is not valid.";
    {
      let n = this.stateFactories[t]();
      if (n !== null)
        return n.ruleIndex = e, n;
    }
  }
  lexerActionFactory(t, e, n) {
    if (this.actionFactories === null) {
      let s = [];
      s[y.CHANNEL] = (r, o) => new Ce(r), s[y.CUSTOM] = (r, o) => new ye(r, o), s[y.MODE] = (r, o) => new ke(r), s[y.MORE] = (r, o) => Xt.INSTANCE, s[y.POP_MODE] = (r, o) => zt.INSTANCE, s[y.PUSH_MODE] = (r, o) => new Ie(r), s[y.SKIP] = (r, o) => Wt.INSTANCE, s[y.TYPE] = (r, o) => new _e(r), this.actionFactories = s;
    }
    if (t > this.actionFactories.length || this.actionFactories[t] === null)
      throw "The specified lexer action type " + t + " is not valid.";
    return this.actionFactories[t](e, n);
  }
};
var $t = class {
  visitTerminal(t) {
  }
  visitErrorNode(t) {
  }
  enterEveryRule(t) {
  }
  exitEveryRule(t) {
  }
};
var Re = class extends $t {
  constructor(t) {
    super(), this.parser = t;
  }
  enterEveryRule(t) {
    console.log("enter   " + this.parser.ruleNames[t.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
  visitTerminal(t) {
    console.log("consume " + t.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
  }
  exitEveryRule(t) {
    console.log("exit    " + this.parser.ruleNames[t.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
};
var Pt = class extends bt {
  constructor(t) {
    super(), this._input = null, this.errorHandler = new gt(), this._precedenceStack = [], this._precedenceStack.push(0), this._ctx = null, this.buildParseTrees = true, this._tracer = null, this._parseListeners = null, this._syntaxErrors = 0, this.tokenStream = t;
  }
  get context() {
    return this._ctx;
  }
  reset() {
    this._input !== null && this._input.seek(0), this.errorHandler.reset(this), this._ctx = null, this._syntaxErrors = 0, this.setTrace(false), this._precedenceStack = [], this._precedenceStack.push(0), this.interpreter !== null && this.interpreter.reset();
  }
  match(t) {
    let e = this.getCurrentToken();
    return e.type === t ? (this.errorHandler.reportMatch(this), this.consume()) : (e = this.errorHandler.recoverInline(this), this.buildParseTrees && e.tokenIndex === -1 && this._ctx.addErrorNode(e)), e;
  }
  matchWildcard() {
    let t = this.getCurrentToken();
    return t.type > 0 ? (this.errorHandler.reportMatch(this), this.consume()) : (t = this.errorHandler.recoverInline(this), this.buildParseTrees && t.tokenIndex === -1 && this._ctx.addErrorNode(t)), t;
  }
  getParseListeners() {
    return this._parseListeners || [];
  }
  addParseListener(t) {
    if (t === null)
      throw "listener";
    this._parseListeners === null && (this._parseListeners = []), this._parseListeners.push(t);
  }
  removeParseListener(t) {
    if (this._parseListeners !== null) {
      let e = this._parseListeners.indexOf(t);
      e >= 0 && this._parseListeners.splice(e, 1), this._parseListeners.length === 0 && (this._parseListeners = null);
    }
  }
  removeParseListeners() {
    this._parseListeners = null;
  }
  triggerEnterRuleEvent() {
    if (this._parseListeners !== null) {
      let t = this._ctx;
      this._parseListeners.forEach(function(e) {
        e.enterEveryRule(t), t.enterRule(e);
      });
    }
  }
  triggerExitRuleEvent() {
    if (this._parseListeners !== null) {
      let t = this._ctx;
      this._parseListeners.slice(0).reverse().forEach(function(e) {
        t.exitRule(e), e.exitEveryRule(t);
      });
    }
  }
  getTokenFactory() {
    return this._input.tokenSource._factory;
  }
  setTokenFactory(t) {
    this._input.tokenSource._factory = t;
  }
  getATNWithBypassAlts() {
    let t = this.getSerializedATN();
    if (t === null)
      throw "The current parser does not support an ATN with bypass alternatives.";
    let e = this.bypassAltsAtnCache[t];
    if (e === null) {
      let n = new ct();
      n.generateRuleBypassTransitions = true, e = new yt(n).deserialize(t), this.bypassAltsAtnCache[t] = e;
    }
    return e;
  }
  get tokenStream() {
    return this._input;
  }
  set tokenStream(t) {
    this._input = null, this.reset(), this._input = t;
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(t) {
    this.tokenStream = t;
  }
  get syntaxErrorsCount() {
    return this._syntaxErrors;
  }
  getCurrentToken() {
    return this._input.LT(1);
  }
  notifyErrorListeners(t, e, n) {
    e = e || null, n = n || null, e === null && (e = this.getCurrentToken()), this._syntaxErrors += 1;
    let s = e.line, r = e.column;
    this.getErrorListenerDispatch().syntaxError(this, e, s, r, t, n);
  }
  consume() {
    let t = this.getCurrentToken();
    t.type !== h.EOF && this.tokenStream.consume();
    let e = this._parseListeners !== null && this._parseListeners.length > 0;
    if (this.buildParseTrees || e) {
      let n;
      this.errorHandler.inErrorRecoveryMode(this) ? n = this._ctx.addErrorNode(t) : n = this._ctx.addTokenNode(t), n.invokingState = this.state, e && this._parseListeners.forEach(function(s) {
        n instanceof it || n.isErrorNode !== void 0 && n.isErrorNode() ? s.visitErrorNode(n) : n instanceof w && s.visitTerminal(n);
      });
    }
    return t;
  }
  addContextToParseTree() {
    this._ctx.parent !== null && this._ctx.parent.addChild(this._ctx);
  }
  enterRule(t, e, n) {
    this.state = e, this._ctx = t, this._ctx.start = this._input.LT(1), this.buildParseTrees && this.addContextToParseTree(), this.triggerEnterRuleEvent();
  }
  exitRule() {
    this._ctx.stop = this._input.LT(-1), this.triggerExitRuleEvent(), this.state = this._ctx.invokingState, this._ctx = this._ctx.parent;
  }
  enterOuterAlt(t, e) {
    t.setAltNumber(e), this.buildParseTrees && this._ctx !== t && this._ctx.parent !== null && (this._ctx.parent.removeLastChild(), this._ctx.parent.addChild(t)), this._ctx = t;
  }
  getPrecedence() {
    return this._precedenceStack.length === 0 ? -1 : this._precedenceStack[this._precedenceStack.length - 1];
  }
  enterRecursionRule(t, e, n, s) {
    this.state = e, this._precedenceStack.push(s), this._ctx = t, this._ctx.start = this._input.LT(1), this.triggerEnterRuleEvent();
  }
  pushNewRecursionContext(t, e, n) {
    let s = this._ctx;
    s._parent = t, s.invokingState = e, s.stop = this._input.LT(-1), this._ctx = t, this._ctx.start = s.start, this.buildParseTrees && this._ctx.addChild(s), this.triggerEnterRuleEvent();
  }
  unrollRecursionContexts(t) {
    this._precedenceStack.pop(), this._ctx.stop = this._input.LT(-1);
    let e = this._ctx, n = this.getParseListeners();
    if (n !== null && n.length > 0)
      for (; this._ctx !== t; )
        this.triggerExitRuleEvent(), this._ctx = this._ctx.parent;
    else
      this._ctx = t;
    e._parent = t, this.buildParseTrees && t !== null && t.addChild(e);
  }
  getInvokingContext(t) {
    let e = this._ctx;
    for (; e !== null; ) {
      if (e.ruleIndex === t)
        return e;
      e = e.parent;
    }
    return null;
  }
  precpred(t, e) {
    return e >= this._precedenceStack[this._precedenceStack.length - 1];
  }
  inContext(t) {
    return false;
  }
  isExpectedToken(t) {
    let e = this.interpreter.atn, n = this._ctx, s = e.states[this.state], r = e.nextTokens(s);
    if (r.contains(t))
      return true;
    if (!r.contains(h.EPSILON))
      return false;
    for (; n !== null && n.invokingState >= 0 && r.contains(h.EPSILON); ) {
      let l = e.states[n.invokingState].transitions[0];
      if (r = e.nextTokens(l.followState), r.contains(t))
        return true;
      n = n.parent;
    }
    return !!(r.contains(h.EPSILON) && t === h.EOF);
  }
  getExpectedTokens() {
    return this.interpreter.atn.getExpectedTokens(this.state, this._ctx);
  }
  getExpectedTokensWithinCurrentRule() {
    let t = this.interpreter.atn, e = t.states[this.state];
    return t.nextTokens(e);
  }
  getRuleIndex(t) {
    let e = this.getRuleIndexMap().get(t);
    return e !== null ? e : -1;
  }
  getRuleInvocationStack(t) {
    t = t || null, t === null && (t = this._ctx);
    let e = [];
    for (; t !== null; ) {
      let n = t.ruleIndex;
      n < 0 ? e.push("n/a") : e.push(this.ruleNames[n]), t = t.parent;
    }
    return e;
  }
  getDFAStrings() {
    return this.interpreter.decisionToDFA.toString();
  }
  dumpDFA() {
    let t = false;
    for (let e = 0; e < this.interpreter.decisionToDFA.length; e++) {
      let n = this.interpreter.decisionToDFA[e];
      n.states.length > 0 && (t && console.log(), console.log("Decision " + n.decision + ":"), console.log(n.toString(this.vocabulary)), t = true);
    }
  }
  getSourceName() {
    return this._input.sourceName;
  }
  setTrace(t) {
    t ? (this._tracer !== null && this.removeParseListener(this._tracer), this._tracer = new Re(this), this.addParseListener(this._tracer)) : (this.removeParseListener(this._tracer), this._tracer = null);
  }
  createTerminalNode(t, e) {
    return new dt(e);
  }
  createErrorNode(t, e) {
    return new Lt(e);
  }
};
Pt.bypassAltsAtnCache = {};
function dn(i32) {
  return i32.hashCodeForConfigSet();
}
function pn(i32, t) {
  return i32 === t ? true : i32 === null || t === null ? false : i32.equalsForConfigSet(t);
}
var I = class i25 {
  constructor(t) {
    this.configLookup = new k(dn, pn), this.fullCtx = t === void 0 ? true : t, this.readOnly = false, this.configs = [], this.uniqueAlt = 0, this.conflictingAlts = null, this.hasSemanticContext = false, this.dipsIntoOuterContext = false, this.cachedHashCode = -1;
  }
  add(t, e) {
    if (e === void 0 && (e = null), this.readOnly)
      throw "This set is readonly";
    t.semanticContext !== T.NONE && (this.hasSemanticContext = true), t.reachesIntoOuterContext > 0 && (this.dipsIntoOuterContext = true);
    let n = this.configLookup.add(t);
    if (n === t)
      return this.cachedHashCode = -1, this.configs.push(t), true;
    let s = !this.fullCtx, r = Ae(n.context, t.context, s, e);
    return n.reachesIntoOuterContext = Math.max(n.reachesIntoOuterContext, t.reachesIntoOuterContext), t.precedenceFilterSuppressed && (n.precedenceFilterSuppressed = true), n.context = r, true;
  }
  getStates() {
    let t = new k();
    for (let e = 0; e < this.configs.length; e++)
      t.add(this.configs[e].state);
    return t;
  }
  getPredicates() {
    let t = [];
    for (let e = 0; e < this.configs.length; e++) {
      let n = this.configs[e].semanticContext;
      n !== T.NONE && t.push(n.semanticContext);
    }
    return t;
  }
  optimizeConfigs(t) {
    if (this.readOnly)
      throw "This set is readonly";
    if (this.configLookup.length !== 0)
      for (let e = 0; e < this.configs.length; e++) {
        let n = this.configs[e];
        n.context = t.getCachedContext(n.context);
      }
  }
  addAll(t) {
    for (let e = 0; e < t.length; e++)
      this.add(t[e]);
    return false;
  }
  equals(t) {
    return this === t || t instanceof i25 && pt(this.configs, t.configs) && this.fullCtx === t.fullCtx && this.uniqueAlt === t.uniqueAlt && this.conflictingAlts === t.conflictingAlts && this.hasSemanticContext === t.hasSemanticContext && this.dipsIntoOuterContext === t.dipsIntoOuterContext;
  }
  hashCode() {
    let t = new R();
    return t.update(this.configs), t.finish();
  }
  updateHashCode(t) {
    this.readOnly ? (this.cachedHashCode === -1 && (this.cachedHashCode = this.hashCode()), t.update(this.cachedHashCode)) : t.update(this.hashCode());
  }
  isEmpty() {
    return this.configs.length === 0;
  }
  contains(t) {
    if (this.configLookup === null)
      throw "This method is not implemented for readonly sets.";
    return this.configLookup.contains(t);
  }
  containsFast(t) {
    if (this.configLookup === null)
      throw "This method is not implemented for readonly sets.";
    return this.configLookup.containsFast(t);
  }
  clear() {
    if (this.readOnly)
      throw "This set is readonly";
    this.configs = [], this.cachedHashCode = -1, this.configLookup = new k();
  }
  setReadonly(t) {
    this.readOnly = t, t && (this.configLookup = null);
  }
  toString() {
    return G(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== S.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
  }
  get items() {
    return this.configs;
  }
  get length() {
    return this.configs.length;
  }
};
var X = class i26 {
  constructor(t, e) {
    return t === null && (t = -1), e === null && (e = new I()), this.stateNumber = t, this.configs = e, this.edges = null, this.isAcceptState = false, this.prediction = 0, this.lexerActionExecutor = null, this.requiresFullContext = false, this.predicates = null, this;
  }
  getAltSet() {
    let t = new k();
    if (this.configs !== null)
      for (let e = 0; e < this.configs.length; e++) {
        let n = this.configs[e];
        t.add(n.alt);
      }
    return t.length === 0 ? null : t;
  }
  equals(t) {
    return this === t || t instanceof i26 && this.configs.equals(t.configs);
  }
  toString() {
    let t = "" + this.stateNumber + ":" + this.configs;
    return this.isAcceptState && (t = t + "=>", this.predicates !== null ? t = t + this.predicates : t = t + this.prediction), t;
  }
  hashCode() {
    let t = new R();
    return t.update(this.configs), t.finish();
  }
};
var V = class {
  constructor(t, e) {
    return this.atn = t, this.sharedContextCache = e, this;
  }
  getCachedContext(t) {
    if (this.sharedContextCache === null)
      return t;
    let e = new Q();
    return Qe(t, this.sharedContextCache, e);
  }
};
V.ERROR = new X(2147483647, new I());
var ce = class extends I {
  constructor() {
    super(), this.configLookup = new k();
  }
};
var z = class i27 extends C {
  constructor(t, e) {
    super(t, e);
    let n = t.lexerActionExecutor || null;
    return this.lexerActionExecutor = n || (e !== null ? e.lexerActionExecutor : null), this.passedThroughNonGreedyDecision = e !== null ? this.checkNonGreedyDecision(e, this.state) : false, this.hashCodeForConfigSet = i27.prototype.hashCode, this.equalsForConfigSet = i27.prototype.equals, this;
  }
  updateHashCode(t) {
    t.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
  }
  equals(t) {
    return this === t || t instanceof i27 && this.passedThroughNonGreedyDecision === t.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(t.lexerActionExecutor) : !t.lexerActionExecutor) && super.equals(t);
  }
  checkNonGreedyDecision(t, e) {
    return t.passedThroughNonGreedyDecision || e instanceof B && e.nonGreedy;
  }
};
var Qt = class i28 extends F {
  constructor(t, e) {
    super(e.actionType), this.offset = t, this.action = e, this.isPositionDependent = true;
  }
  execute(t) {
    this.action.execute(t);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.offset, this.action);
  }
  equals(t) {
    return this === t ? true : t instanceof i28 ? this.offset === t.offset && this.action === t.action : false;
  }
};
var Pe = class i29 {
  constructor(t) {
    return this.lexerActions = t === null ? [] : t, this.cachedHashCode = R.hashStuff(t), this;
  }
  fixOffsetBeforeMatch(t) {
    let e = null;
    for (let n = 0; n < this.lexerActions.length; n++)
      this.lexerActions[n].isPositionDependent && !(this.lexerActions[n] instanceof Qt) && (e === null && (e = this.lexerActions.concat([])), e[n] = new Qt(t, this.lexerActions[n]));
    return e === null ? this : new i29(e);
  }
  execute(t, e, n) {
    let s = false, r = e.index;
    try {
      for (let o = 0; o < this.lexerActions.length; o++) {
        let l = this.lexerActions[o];
        if (l instanceof Qt) {
          let a = l.offset;
          e.seek(n + a), l = l.action, s = n + a !== r;
        } else
          l.isPositionDependent && (e.seek(r), s = false);
        l.execute(t);
      }
    } finally {
      s && e.seek(r);
    }
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(t) {
    t.update(this.cachedHashCode);
  }
  equals(t) {
    if (this === t)
      return true;
    if (t instanceof i29) {
      if (this.cachedHashCode != t.cachedHashCode)
        return false;
      if (this.lexerActions.length != t.lexerActions.length)
        return false;
      {
        let e = this.lexerActions.length;
        for (let n = 0; n < e; ++n)
          if (!this.lexerActions[n].equals(t.lexerActions[n]))
            return false;
        return true;
      }
    } else
      return false;
  }
  static append(t, e) {
    if (t === null)
      return new i29([e]);
    let n = t.lexerActions.concat([e]);
    return new i29(n);
  }
};
function on(i32) {
  i32.index = -1, i32.line = 0, i32.column = -1, i32.dfaState = null;
}
var tn = class {
  constructor() {
    on(this);
  }
  reset() {
    on(this);
  }
};
var Z = class i30 extends V {
  constructor(t, e, n, s) {
    super(e, s), this.decisionToDFA = n, this.recog = t, this.startIndex = -1, this.line = 1, this.column = 0, this.mode = N.DEFAULT_MODE, this.prevAccept = new tn();
  }
  copyState(t) {
    this.column = t.column, this.line = t.line, this.mode = t.mode, this.startIndex = t.startIndex;
  }
  match(t, e) {
    this.mode = e;
    let n = t.mark();
    try {
      this.startIndex = t.index, this.prevAccept.reset();
      let s = this.decisionToDFA[e];
      return s.s0 === null ? this.matchATN(t) : this.execATN(t, s.s0);
    } finally {
      t.release(n);
    }
  }
  reset() {
    this.prevAccept.reset(), this.startIndex = -1, this.line = 1, this.column = 0, this.mode = N.DEFAULT_MODE;
  }
  matchATN(t) {
    let e = this.atn.modeToStartState[this.mode];
    i30.debug && console.log("matchATN mode " + this.mode + " start: " + e);
    let n = this.mode, s = this.computeStartState(t, e), r = s.hasSemanticContext;
    s.hasSemanticContext = false;
    let o = this.addDFAState(s);
    r || (this.decisionToDFA[this.mode].s0 = o);
    let l = this.execATN(t, o);
    return i30.debug && console.log("DFA after matchATN: " + this.decisionToDFA[n].toLexerString()), l;
  }
  execATN(t, e) {
    i30.debug && console.log("start state closure=" + e.configs), e.isAcceptState && this.captureSimState(this.prevAccept, t, e);
    let n = t.LA(1), s = e;
    for (; ; ) {
      i30.debug && console.log("execATN loop starting closure: " + s.configs);
      let r = this.getExistingTargetState(s, n);
      if (r === null && (r = this.computeTargetState(t, s, n)), r === V.ERROR || (n !== h.EOF && this.consume(t), r.isAcceptState && (this.captureSimState(this.prevAccept, t, r), n === h.EOF)))
        break;
      n = t.LA(1), s = r;
    }
    return this.failOrAccept(this.prevAccept, t, s.configs, n);
  }
  getExistingTargetState(t, e) {
    if (t.edges === null || e < i30.MIN_DFA_EDGE || e > i30.MAX_DFA_EDGE)
      return null;
    let n = t.edges[e - i30.MIN_DFA_EDGE];
    return n === void 0 && (n = null), i30.debug && n !== null && console.log("reuse state " + t.stateNumber + " edge to " + n.stateNumber), n;
  }
  computeTargetState(t, e, n) {
    let s = new ce();
    return this.getReachableConfigSet(t, e.configs, s, n), s.items.length === 0 ? (s.hasSemanticContext || this.addDFAEdge(e, n, V.ERROR), V.ERROR) : this.addDFAEdge(e, n, null, s);
  }
  failOrAccept(t, e, n, s) {
    if (this.prevAccept.dfaState !== null) {
      let r = t.dfaState.lexerActionExecutor;
      return this.accept(e, r, this.startIndex, t.index, t.line, t.column), t.dfaState.prediction;
    } else {
      if (s === h.EOF && e.index === this.startIndex)
        return h.EOF;
      throw new rt(this.recog, e, this.startIndex, n);
    }
  }
  getReachableConfigSet(t, e, n, s) {
    let r = S.INVALID_ALT_NUMBER;
    for (let o = 0; o < e.items.length; o++) {
      let l = e.items[o], a = l.alt === r;
      if (!(a && l.passedThroughNonGreedyDecision)) {
        i30.debug && console.log(`testing %s at %s
`, this.getTokenName(s), l.toString(this.recog, true));
        for (let u = 0; u < l.state.transitions.length; u++) {
          let c = l.state.transitions[u], f = this.getReachableTarget(c, s);
          if (f !== null) {
            let p = l.lexerActionExecutor;
            p !== null && (p = p.fixOffsetBeforeMatch(t.index - this.startIndex));
            let E = s === h.EOF, tt = new z({ state: f, lexerActionExecutor: p }, l);
            this.closure(t, tt, n, a, true, E) && (r = l.alt);
          }
        }
      }
    }
  }
  accept(t, e, n, s, r, o) {
    i30.debug && console.log(`ACTION %s
`, e), t.seek(s), this.line = r, this.column = o, e !== null && this.recog !== null && e.execute(this.recog, t, n);
  }
  getReachableTarget(t, e) {
    return t.matches(e, 0, N.MAX_CHAR_VALUE) ? t.target : null;
  }
  computeStartState(t, e) {
    let n = x.EMPTY, s = new ce();
    for (let r = 0; r < e.transitions.length; r++) {
      let o = e.transitions[r].target, l = new z({ state: o, alt: r + 1, context: n }, null);
      this.closure(t, l, s, false, false, false);
    }
    return s;
  }
  closure(t, e, n, s, r, o) {
    let l = null;
    if (i30.debug && console.log("closure(" + e.toString(this.recog, true) + ")"), e.state instanceof L) {
      if (i30.debug && (this.recog !== null ? console.log(`closure at %s rule stop %s
`, this.recog.ruleNames[e.state.ruleIndex], e) : console.log(`closure at rule stop %s
`, e)), e.context === null || e.context.hasEmptyPath()) {
        if (e.context === null || e.context.isEmpty())
          return n.add(e), true;
        n.add(new z({ state: e.state, context: x.EMPTY }, e)), s = true;
      }
      if (e.context !== null && !e.context.isEmpty()) {
        for (let a = 0; a < e.context.length; a++)
          if (e.context.getReturnState(a) !== x.EMPTY_RETURN_STATE) {
            let u = e.context.getParent(a), c = this.atn.states[e.context.getReturnState(a)];
            l = new z({ state: c, context: u }, e), s = this.closure(t, l, n, s, r, o);
          }
      }
      return s;
    }
    e.state.epsilonOnlyTransitions || (!s || !e.passedThroughNonGreedyDecision) && n.add(e);
    for (let a = 0; a < e.state.transitions.length; a++) {
      let u = e.state.transitions[a];
      l = this.getEpsilonTarget(t, e, u, n, r, o), l !== null && (s = this.closure(t, l, n, s, r, o));
    }
    return s;
  }
  getEpsilonTarget(t, e, n, s, r, o) {
    let l = null;
    if (n.serializationType === d.RULE) {
      let a = v.create(e.context, n.followState.stateNumber);
      l = new z({ state: n.target, context: a }, e);
    } else {
      if (n.serializationType === d.PRECEDENCE)
        throw "Precedence predicates are not supported in lexers.";
      if (n.serializationType === d.PREDICATE)
        i30.debug && console.log("EVAL rule " + n.ruleIndex + ":" + n.predIndex), s.hasSemanticContext = true, this.evaluatePredicate(t, n.ruleIndex, n.predIndex, r) && (l = new z({ state: n.target }, e));
      else if (n.serializationType === d.ACTION)
        if (e.context === null || e.context.hasEmptyPath()) {
          let a = Pe.append(e.lexerActionExecutor, this.atn.lexerActions[n.actionIndex]);
          l = new z({ state: n.target, lexerActionExecutor: a }, e);
        } else
          l = new z({ state: n.target }, e);
      else
        n.serializationType === d.EPSILON ? l = new z({ state: n.target }, e) : (n.serializationType === d.ATOM || n.serializationType === d.RANGE || n.serializationType === d.SET) && o && n.matches(h.EOF, 0, N.MAX_CHAR_VALUE) && (l = new z({ state: n.target }, e));
    }
    return l;
  }
  evaluatePredicate(t, e, n, s) {
    if (this.recog === null)
      return true;
    if (!s)
      return this.recog.sempred(null, e, n);
    let r = this.column, o = this.line, l = t.index, a = t.mark();
    try {
      return this.consume(t), this.recog.sempred(null, e, n);
    } finally {
      this.column = r, this.line = o, t.seek(l), t.release(a);
    }
  }
  captureSimState(t, e, n) {
    t.index = e.index, t.line = this.line, t.column = this.column, t.dfaState = n;
  }
  addDFAEdge(t, e, n, s) {
    if (n === void 0 && (n = null), s === void 0 && (s = null), n === null && s !== null) {
      let r = s.hasSemanticContext;
      if (s.hasSemanticContext = false, n = this.addDFAState(s), r)
        return n;
    }
    return e < i30.MIN_DFA_EDGE || e > i30.MAX_DFA_EDGE || (i30.debug && console.log("EDGE " + t + " -> " + n + " upon " + e), t.edges === null && (t.edges = []), t.edges[e - i30.MIN_DFA_EDGE] = n), n;
  }
  addDFAState(t) {
    let e = new X(null, t), n = null;
    for (let l = 0; l < t.items.length; l++) {
      let a = t.items[l];
      if (a.state instanceof L) {
        n = a;
        break;
      }
    }
    n !== null && (e.isAcceptState = true, e.lexerActionExecutor = n.lexerActionExecutor, e.prediction = this.atn.ruleToTokenType[n.state.ruleIndex]);
    let s = this.decisionToDFA[this.mode], r = s.states.get(e);
    if (r !== null)
      return r;
    let o = e;
    return o.stateNumber = s.states.length, t.setReadonly(true), o.configs = t, s.states.add(o), o;
  }
  getDFA(t) {
    return this.decisionToDFA[t];
  }
  getText(t) {
    return t.getText(this.startIndex, t.index - 1);
  }
  consume(t) {
    t.LA(1) === `
`.charCodeAt(0) ? (this.line += 1, this.column = 0) : this.column += 1, t.consume();
  }
  getTokenName(t) {
    return t === -1 ? "EOF" : "'" + String.fromCharCode(t) + "'";
  }
};
Z.debug = false;
Z.dfa_debug = false;
Z.MIN_DFA_EDGE = 0;
Z.MAX_DFA_EDGE = 127;
var lt = class {
  constructor() {
    this.cache = new Q();
  }
  add(t) {
    if (t === x.EMPTY)
      return x.EMPTY;
    let e = this.cache.get(t) || null;
    return e !== null ? e : (this.cache.set(t, t), t);
  }
  get(t) {
    return this.cache.get(t) || null;
  }
  get length() {
    return this.cache.length;
  }
};
var Zt = class {
  constructor(t, e, n) {
    this.dfa = t, this.literalNames = e || [], this.symbolicNames = n || [];
  }
  toString() {
    if (this.dfa.s0 === null)
      return null;
    let t = "", e = this.dfa.sortedStates();
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.edges !== null) {
        let r = s.edges.length;
        for (let o = 0; o < r; o++) {
          let l = s.edges[o] || null;
          l !== null && l.stateNumber !== 2147483647 && (t = t.concat(this.getStateString(s)), t = t.concat("-"), t = t.concat(this.getEdgeLabel(o)), t = t.concat("->"), t = t.concat(this.getStateString(l)), t = t.concat(`
`));
        }
      }
    }
    return t.length === 0 ? null : t;
  }
  getEdgeLabel(t) {
    return t === 0 ? "EOF" : this.literalNames !== null || this.symbolicNames !== null ? this.literalNames[t - 1] || this.symbolicNames[t - 1] : String.fromCharCode(t - 1);
  }
  getStateString(t) {
    let e = (t.isAcceptState ? ":" : "") + "s" + t.stateNumber + (t.requiresFullContext ? "^" : "");
    return t.isAcceptState ? t.predicates !== null ? e + "=>" + G(t.predicates) : e + "=>" + t.prediction.toString() : e;
  }
};
var Fe = class extends Zt {
  constructor(t) {
    super(t, null);
  }
  getEdgeLabel(t) {
    return "'" + String.fromCharCode(t) + "'";
  }
};
var at = class {
  constructor(t, e) {
    if (e === void 0 && (e = 0), this.atnStartState = t, this.decision = e, this._states = new k(), this.s0 = null, this.precedenceDfa = false, t instanceof Y && t.precedenceRuleDecision) {
      this.precedenceDfa = true;
      let n = new X(null, new I());
      n.edges = [], n.isAcceptState = false, n.requiresFullContext = false, this.s0 = n;
    }
  }
  getPrecedenceStartState(t) {
    if (!this.precedenceDfa)
      throw "Only precedence DFAs may contain a precedence start state.";
    return t < 0 || t >= this.s0.edges.length ? null : this.s0.edges[t] || null;
  }
  setPrecedenceStartState(t, e) {
    if (!this.precedenceDfa)
      throw "Only precedence DFAs may contain a precedence start state.";
    t < 0 || (this.s0.edges[t] = e);
  }
  setPrecedenceDfa(t) {
    if (this.precedenceDfa !== t) {
      if (this._states = new k(), t) {
        let e = new X(null, new I());
        e.edges = [], e.isAcceptState = false, e.requiresFullContext = false, this.s0 = e;
      } else
        this.s0 = null;
      this.precedenceDfa = t;
    }
  }
  sortedStates() {
    return this._states.values().sort(function(e, n) {
      return e.stateNumber - n.stateNumber;
    });
  }
  toString(t, e) {
    return t = t || null, e = e || null, this.s0 === null ? "" : new Zt(this, t, e).toString();
  }
  toLexerString() {
    return this.s0 === null ? "" : new Fe(this).toString();
  }
  get states() {
    return this._states;
  }
};
var nt = class extends U {
  constructor(t, e) {
    super(t, e), this.children = null, this.start = null, this.stop = null, this.exception = null;
  }
  copyFrom(t) {
    this._parent = t._parent, this.invokingState = t.invokingState, this.children = null, this.start = t.start, this.stop = t.stop, t.children && (this.children = [], t.children.map(function(e) {
      e instanceof Lt && (this.children.push(e), e.parent = this);
    }, this));
  }
  enterRule(t) {
  }
  exitRule(t) {
  }
  addChild(t) {
    return this.children === null && (this.children = []), this.children.push(t), t;
  }
  removeLastChild() {
    this.children !== null && this.children.pop();
  }
  addTokenNode(t) {
    let e = new dt(t);
    return this.addChild(e), e.parent = this, e;
  }
  addErrorNode(t) {
    let e = new Lt(t);
    return this.addChild(e), e.parent = this, e;
  }
  getChild(t, e) {
    if (e = e ?? null, this.children === null || t < 0 || t >= this.children.length)
      return null;
    if (e === null)
      return this.children[t];
    for (let n = 0; n < this.children.length; n++) {
      let s = this.children[n];
      if (s instanceof e) {
        if (t === 0)
          return s;
        t -= 1;
      }
    }
    return null;
  }
  getToken(t, e) {
    if (this.children === null || e < 0 || e >= this.children.length)
      return null;
    for (let n = 0; n < this.children.length; n++) {
      let s = this.children[n];
      if (s instanceof w && s.symbol.type === t) {
        if (e === 0)
          return s;
        e -= 1;
      }
    }
    return null;
  }
  getTokens(t) {
    if (this.children === null)
      return [];
    {
      let e = [];
      for (let n = 0; n < this.children.length; n++) {
        let s = this.children[n];
        s instanceof w && s.symbol.type === t && e.push(s);
      }
      return e;
    }
  }
  getRuleContext(t, e) {
    return this.getChild(t, e);
  }
  getRuleContexts(t) {
    if (this.children === null)
      return [];
    {
      let e = [];
      for (let n = 0; n < this.children.length; n++) {
        let s = this.children[n];
        s instanceof t && e.push(s);
      }
      return e;
    }
  }
  getChildCount() {
    return this.children === null ? 0 : this.children.length;
  }
  getSourceInterval() {
    return this.start === null || this.stop === null ? g.INVALID_INTERVAL : new g(this.start.tokenIndex, this.stop.tokenIndex);
  }
};
U.EMPTY = new nt();
var se = class {
  walk(t, e) {
    if (e instanceof it || e.isErrorNode !== void 0 && e.isErrorNode())
      t.visitErrorNode(e);
    else if (e instanceof w)
      t.visitTerminal(e);
    else {
      this.enterRule(t, e);
      for (let s = 0; s < e.getChildCount(); s++) {
        let r = e.getChild(s);
        this.walk(t, r);
      }
      this.exitRule(t, e);
    }
  }
  enterRule(t, e) {
    let n = e.ruleContext;
    t.enterEveryRule(n), n.enterRule(t);
  }
  exitRule(t, e) {
    let n = e.ruleContext;
    n.exitRule(t), t.exitEveryRule(n);
  }
};
se.DEFAULT = new se();
var K = class i31 extends N {
  static TOKEN_REF = 1;
  static RULE_REF = 2;
  static ANYWHERE = 3;
  static ROOT = 4;
  static WILDCARD = 5;
  static BANG = 6;
  static ID = 7;
  static STRING = 8;
  static EOF = h.EOF;
  static channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
  static literalNames = [null, null, null, "'//'", "'/'", "'*'", "'!'"];
  static symbolicNames = [null, "TOKEN_REF", "RULE_REF", "ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "STRING"];
  static modeNames = ["DEFAULT_MODE"];
  static ruleNames = ["ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "NameChar", "NameStartChar", "STRING"];
  constructor(t) {
    super(t), this.interpreter = new Z(this, i31._ATN, i31.decisionsToDFA, new lt());
  }
  get grammarFileName() {
    return "XPathLexer.g4";
  }
  get literalNames() {
    return i31.literalNames;
  }
  get symbolicNames() {
    return i31.symbolicNames;
  }
  get ruleNames() {
    return i31.ruleNames;
  }
  get serializedATN() {
    return i31._serializedATN;
  }
  get channelNames() {
    return i31.channelNames;
  }
  get modeNames() {
    return i31.modeNames;
  }
  action(t, e, n) {
    switch (e) {
      case 4:
        this.ID_action(t, n);
        break;
    }
  }
  ID_action(t, e) {
    switch (e) {
      case 0: {
        let n = this.text;
        n.charAt(0) === n.charAt(0).toUpperCase() ? this._type = i31.TOKEN_REF : this._type = i31.RULE_REF;
        break;
      }
    }
  }
  static _serializedATN = [4, 0, 8, 48, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4, 5, 4, 29, 8, 4, 10, 4, 12, 4, 32, 9, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 5, 7, 42, 8, 7, 10, 7, 12, 7, 45, 9, 7, 1, 7, 1, 7, 1, 43, 0, 8, 1, 3, 3, 4, 5, 5, 7, 6, 9, 7, 11, 0, 13, 0, 15, 8, 1, 0, 2, 784, 0, 0, 8, 14, 27, 48, 57, 65, 90, 95, 95, 97, 122, 127, 159, 170, 170, 173, 173, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1519, 1522, 1536, 1541, 1552, 1562, 1564, 1564, 1568, 1641, 1646, 1747, 1749, 1757, 1759, 1768, 1770, 1788, 1791, 1791, 1807, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2045, 2045, 2048, 2093, 2112, 2139, 2144, 2154, 2160, 2183, 2185, 2190, 2192, 2193, 2200, 2403, 2406, 2415, 2417, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2556, 2556, 2558, 2558, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2809, 2815, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2901, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3072, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3132, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3162, 3165, 3165, 3168, 3171, 3174, 3183, 3200, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3293, 3294, 3296, 3299, 3302, 3311, 3313, 3315, 3328, 3340, 3342, 3344, 3346, 3396, 3398, 3400, 3402, 3406, 3412, 3415, 3423, 3427, 3430, 3439, 3450, 3455, 3457, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3773, 3776, 3780, 3782, 3782, 3784, 3790, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5909, 5919, 5940, 5952, 5971, 5984, 5996, 5998, 6e3, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6430, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6832, 6845, 6847, 6862, 6912, 6988, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7376, 7378, 7380, 7418, 7424, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8203, 8207, 8234, 8238, 8255, 8256, 8276, 8276, 8288, 8292, 8294, 8303, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12735, 12784, 12799, 13312, 19903, 19968, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42737, 42775, 42783, 42786, 42888, 42891, 42954, 42960, 42961, 42963, 42963, 42965, 42969, 42994, 43047, 43052, 43052, 43072, 43123, 43136, 43205, 43216, 43225, 43232, 43255, 43259, 43259, 43261, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43488, 43518, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43881, 43888, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65071, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65279, 65279, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65529, 65531, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66045, 66045, 66176, 66204, 66208, 66256, 66272, 66272, 66304, 66335, 66349, 66378, 66384, 66426, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66928, 66938, 66940, 66954, 66956, 66962, 66964, 66965, 66967, 66977, 66979, 66993, 66995, 67001, 67003, 67004, 67072, 67382, 67392, 67413, 67424, 67431, 67456, 67461, 67463, 67504, 67506, 67514, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68099, 68101, 68102, 68108, 68115, 68117, 68119, 68121, 68149, 68152, 68154, 68159, 68159, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68326, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68903, 68912, 68921, 69248, 69289, 69291, 69292, 69296, 69297, 69373, 69404, 69415, 69415, 69424, 69456, 69488, 69509, 69552, 69572, 69600, 69622, 69632, 69702, 69734, 69749, 69759, 69818, 69821, 69821, 69826, 69826, 69837, 69837, 69840, 69864, 69872, 69881, 69888, 69940, 69942, 69951, 69956, 69959, 69968, 70003, 70006, 70006, 70016, 70084, 70089, 70092, 70094, 70106, 70108, 70108, 70144, 70161, 70163, 70199, 70206, 70209, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70378, 70384, 70393, 70400, 70403, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70459, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70730, 70736, 70745, 70750, 70753, 70784, 70853, 70855, 70855, 70864, 70873, 71040, 71093, 71096, 71104, 71128, 71133, 71168, 71232, 71236, 71236, 71248, 71257, 71296, 71352, 71360, 71369, 71424, 71450, 71453, 71467, 71472, 71481, 71488, 71494, 71680, 71738, 71840, 71913, 71935, 71942, 71945, 71945, 71948, 71955, 71957, 71958, 71960, 71989, 71991, 71992, 71995, 72003, 72016, 72025, 72096, 72103, 72106, 72151, 72154, 72161, 72163, 72164, 72192, 72254, 72263, 72263, 72272, 72345, 72349, 72349, 72368, 72440, 72704, 72712, 72714, 72758, 72760, 72768, 72784, 72793, 72818, 72847, 72850, 72871, 72873, 72886, 72960, 72966, 72968, 72969, 72971, 73014, 73018, 73018, 73020, 73021, 73023, 73031, 73040, 73049, 73056, 73061, 73063, 73064, 73066, 73102, 73104, 73105, 73107, 73112, 73120, 73129, 73440, 73462, 73472, 73488, 73490, 73530, 73534, 73538, 73552, 73561, 73648, 73648, 73728, 74649, 74752, 74862, 74880, 75075, 77712, 77808, 77824, 78933, 82944, 83526, 92160, 92728, 92736, 92766, 92768, 92777, 92784, 92862, 92864, 92873, 92880, 92909, 92912, 92916, 92928, 92982, 92992, 92995, 93008, 93017, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94031, 94087, 94095, 94111, 94176, 94177, 94179, 94180, 94192, 94193, 94208, 100343, 100352, 101589, 101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882, 110898, 110898, 110928, 110930, 110933, 110933, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 113824, 113827, 118528, 118573, 118576, 118598, 119141, 119145, 119149, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476, 121499, 121503, 121505, 121519, 122624, 122654, 122661, 122666, 122880, 122886, 122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922, 122928, 122989, 123023, 123023, 123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214, 123536, 123566, 123584, 123641, 124112, 124153, 124896, 124902, 124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124, 125136, 125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 130032, 130041, 131072, 173791, 173824, 177977, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 196608, 201546, 201552, 205743, 917505, 917505, 917536, 917631, 917760, 917999, 662, 0, 65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1488, 1514, 1519, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2144, 2154, 2160, 2183, 2185, 2190, 2208, 2249, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2556, 2556, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2809, 2809, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3162, 3165, 3165, 3168, 3169, 3200, 3200, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3293, 3294, 3296, 3297, 3313, 3314, 3332, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3412, 3414, 3423, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5905, 5919, 5937, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6264, 6272, 6276, 6279, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6988, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7401, 7404, 7406, 7411, 7413, 7414, 7418, 7418, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12735, 12784, 12799, 13312, 19903, 19968, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42653, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42954, 42960, 42961, 42963, 42963, 42965, 42969, 42994, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43261, 43262, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43881, 43888, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66349, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66928, 66938, 66940, 66954, 66956, 66962, 66964, 66965, 66967, 66977, 66979, 66993, 66995, 67001, 67003, 67004, 67072, 67382, 67392, 67413, 67424, 67431, 67456, 67461, 67463, 67504, 67506, 67514, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68149, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68899, 69248, 69289, 69296, 69297, 69376, 69404, 69415, 69415, 69424, 69445, 69488, 69505, 69552, 69572, 69600, 69622, 69635, 69687, 69745, 69746, 69749, 69749, 69763, 69807, 69840, 69864, 69891, 69926, 69956, 69956, 69959, 69959, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70108, 70108, 70144, 70161, 70163, 70187, 70207, 70208, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70480, 70480, 70493, 70497, 70656, 70708, 70727, 70730, 70751, 70753, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71128, 71131, 71168, 71215, 71236, 71236, 71296, 71338, 71352, 71352, 71424, 71450, 71488, 71494, 71680, 71723, 71840, 71903, 71935, 71942, 71945, 71945, 71948, 71955, 71957, 71958, 71960, 71983, 71999, 71999, 72001, 72001, 72096, 72103, 72106, 72144, 72161, 72161, 72163, 72163, 72192, 72192, 72203, 72242, 72250, 72250, 72272, 72272, 72284, 72329, 72349, 72349, 72368, 72440, 72704, 72712, 72714, 72750, 72768, 72768, 72818, 72847, 72960, 72966, 72968, 72969, 72971, 73008, 73030, 73030, 73056, 73061, 73063, 73064, 73066, 73097, 73112, 73112, 73440, 73458, 73474, 73474, 73476, 73488, 73490, 73523, 73648, 73648, 73728, 74649, 74752, 74862, 74880, 75075, 77712, 77808, 77824, 78895, 78913, 78918, 82944, 83526, 92160, 92728, 92736, 92766, 92784, 92862, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94032, 94032, 94099, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101589, 101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882, 110898, 110898, 110928, 110930, 110933, 110933, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 122624, 122654, 122661, 122666, 122928, 122989, 123136, 123180, 123191, 123197, 123214, 123214, 123536, 123565, 123584, 123627, 124112, 124139, 124896, 124902, 124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173791, 173824, 177977, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 196608, 201546, 201552, 205743, 47, 0, 1, 1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 15, 1, 0, 0, 0, 1, 17, 1, 0, 0, 0, 3, 20, 1, 0, 0, 0, 5, 22, 1, 0, 0, 0, 7, 24, 1, 0, 0, 0, 9, 26, 1, 0, 0, 0, 11, 35, 1, 0, 0, 0, 13, 37, 1, 0, 0, 0, 15, 39, 1, 0, 0, 0, 17, 18, 5, 47, 0, 0, 18, 19, 5, 47, 0, 0, 19, 2, 1, 0, 0, 0, 20, 21, 5, 47, 0, 0, 21, 4, 1, 0, 0, 0, 22, 23, 5, 42, 0, 0, 23, 6, 1, 0, 0, 0, 24, 25, 5, 33, 0, 0, 25, 8, 1, 0, 0, 0, 26, 30, 3, 13, 6, 0, 27, 29, 3, 11, 5, 0, 28, 27, 1, 0, 0, 0, 29, 32, 1, 0, 0, 0, 30, 28, 1, 0, 0, 0, 30, 31, 1, 0, 0, 0, 31, 33, 1, 0, 0, 0, 32, 30, 1, 0, 0, 0, 33, 34, 6, 4, 0, 0, 34, 10, 1, 0, 0, 0, 35, 36, 7, 0, 0, 0, 36, 12, 1, 0, 0, 0, 37, 38, 7, 1, 0, 0, 38, 14, 1, 0, 0, 0, 39, 43, 5, 39, 0, 0, 40, 42, 9, 0, 0, 0, 41, 40, 1, 0, 0, 0, 42, 45, 1, 0, 0, 0, 43, 44, 1, 0, 0, 0, 43, 41, 1, 0, 0, 0, 44, 46, 1, 0, 0, 0, 45, 43, 1, 0, 0, 0, 46, 47, 5, 39, 0, 0, 47, 16, 1, 0, 0, 0, 3, 0, 30, 43, 1, 1, 4, 0];
  static __ATN;
  static get _ATN() {
    return i31.__ATN || (i31.__ATN = new yt().deserialize(i31._serializedATN)), i31.__ATN;
  }
  static vocabulary = new b(i31.literalNames, i31.symbolicNames, []);
  get vocabulary() {
    return i31.vocabulary;
  }
  static decisionsToDFA = i31._ATN.decisionToState.map((t, e) => new at(t, e));
};

// src/utils.ts
var longestCommonPrefix = (arr1, arr2) => {
  if (!arr1 || !arr2) {
    return [];
  }
  let i32;
  for (i32 = 0; i32 < Math.min(arr1.length, arr2.length); i32++) {
    if (arr1[i32] !== arr2[i32]) {
      break;
    }
  }
  return arr1.slice(0, i32);
};

// src/CodeCompletionCore.ts
var CandidatesCollection = class {
  tokens = /* @__PURE__ */ new Map();
  rules = /* @__PURE__ */ new Map();
};
var FollowSetWithPath = class {
  intervals;
  path = [];
  following = [];
};
var CodeCompletionCore = class _CodeCompletionCore {
  static followSetsByATN = /* @__PURE__ */ new Map();
  static atnStateTypeMap = [
    "invalid",
    "basic",
    "rule start",
    "block start",
    "plus block start",
    "star block start",
    "token start",
    "rule stop",
    "block end",
    "star loop back",
    "star loop entry",
    "plus loop back",
    "loop end"
  ];
  // Debugging options. Print human readable ATN state and other info.
  /** Not dependent on showDebugOutput. Prints the collected rules + tokens to terminal. */
  showResult = false;
  /** Enables printing ATN state info to terminal. */
  showDebugOutput = false;
  /** Only relevant when showDebugOutput is true. Enables transition printing for a state. */
  debugOutputWithTransitions = false;
  /** Also depends on showDebugOutput. Enables call stack printing for each rule recursion. */
  showRuleStack = false;
  /**
   * Tailoring of the result:
   * Tokens which should not appear in the candidates set.
   */
  ignoredTokens;
  /**
   * Rules which replace any candidate token they contain.
   * This allows to return descriptive rules (e.g. className, instead of ID/identifier).
   */
  preferredRules;
  /**
   * Specify if preferred rules should translated top-down (higher index rule returns first) or
   * bottom-up (lower index rule returns first).
   */
  translateRulesTopDown = false;
  parser;
  atn;
  vocabulary;
  ruleNames;
  tokens;
  precedenceStack;
  tokenStartIndex = 0;
  statesProcessed = 0;
  /**
   * A mapping of rule index + token stream position to end token positions.
   * A rule which has been visited before with the same input position will always produce the same output positions.
   */
  shortcutMap = /* @__PURE__ */ new Map();
  /** The collected candidates (rules and tokens). */
  candidates = new CandidatesCollection();
  constructor(parser2) {
    this.parser = parser2;
    this.atn = parser2.atn;
    this.vocabulary = parser2.vocabulary;
    this.ruleNames = parser2.ruleNames;
    this.ignoredTokens = /* @__PURE__ */ new Set();
    this.preferredRules = /* @__PURE__ */ new Set();
  }
  /**
   * This is the main entry point. The caret token index specifies the token stream index for the token which
   * currently covers the caret (or any other position you want to get code completion candidates for).
   * Optionally you can pass in a parser rule context which limits the ATN walk to only that or called rules.
   * This can significantly speed up the retrieval process but might miss some candidates (if they are outside of
   * the given context).
   *
   * @param caretTokenIndex The index of the token at the caret position.
   * @param context An option parser rule context to limit the search space.
   * @returns The collection of completion candidates.
   */
  collectCandidates(caretTokenIndex, context) {
    this.shortcutMap.clear();
    this.candidates.rules.clear();
    this.candidates.tokens.clear();
    this.statesProcessed = 0;
    this.precedenceStack = [];
    this.tokenStartIndex = context?.start ? context.start.tokenIndex : 0;
    const tokenStream = this.parser.tokenStream;
    this.tokens = [];
    let offset = this.tokenStartIndex;
    while (true) {
      const token = tokenStream.get(offset++);
      if (token.channel === h.DEFAULT_CHANNEL) {
        this.tokens.push(token);
        if (token.tokenIndex >= caretTokenIndex || token.type === h.EOF) {
          break;
        }
      }
      if (token.type === h.EOF) {
        break;
      }
    }
    const callStack = [];
    const startRule = context ? context.ruleIndex : 0;
    this.processRule(this.atn.ruleToStartState[startRule], 0, callStack, 0, 0);
    if (this.showResult) {
      console.log(`States processed: ${this.statesProcessed}`);
      console.log("\n\nCollected rules:\n");
      for (const rule of this.candidates.rules) {
        let path = "";
        for (const token of rule[1].ruleList) {
          path += this.ruleNames[token] + " ";
        }
        console.log(this.ruleNames[rule[0]] + ", path: ", path);
      }
      const sortedTokens = /* @__PURE__ */ new Set();
      for (const token of this.candidates.tokens) {
        let value = this.vocabulary.getDisplayName(token[0]) ?? "";
        for (const following of token[1]) {
          value += " " + this.vocabulary.getDisplayName(following);
        }
        sortedTokens.add(value);
      }
      console.log("\n\nCollected tokens:\n");
      for (const symbol of sortedTokens) {
        console.log(symbol);
      }
      console.log("\n\n");
    }
    return this.candidates;
  }
  /**
   * Checks if the predicate associated with the given transition evaluates to true.
   *
   * @param transition The transition to check.
   * @returns the evaluation result of the predicate.
   */
  checkPredicate(transition) {
    return transition.getPredicate().evaluate(this.parser, nt.EMPTY);
  }
  /**
   * Walks the rule chain upwards or downwards (depending on translateRulesTopDown) to see if that matches any of the
   * preferred rules. If found, that rule is added to the collection candidates and true is returned.
   *
   * @param ruleWithStartTokenList The list to convert.
   * @returns true if any of the stack entries was converted.
   */
  translateStackToRuleIndex(ruleWithStartTokenList) {
    if (this.preferredRules.size === 0) {
      return false;
    }
    if (this.translateRulesTopDown) {
      for (let i32 = ruleWithStartTokenList.length - 1; i32 >= 0; i32--) {
        if (this.translateToRuleIndex(i32, ruleWithStartTokenList)) {
          return true;
        }
      }
    } else {
      for (let i32 = 0; i32 < ruleWithStartTokenList.length; i32++) {
        if (this.translateToRuleIndex(i32, ruleWithStartTokenList)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Given the index of a rule from a rule chain, check if that matches any of the preferred rules. If it matches,
   * that rule is added to the collection candidates and true is returned.
   *
   * @param i The rule index.
   * @param ruleWithStartTokenList The list to check.
   * @returns true if the specified rule is in the list of preferred rules.
   */
  translateToRuleIndex(i32, ruleWithStartTokenList) {
    const { ruleIndex, startTokenIndex } = ruleWithStartTokenList[i32];
    if (this.preferredRules.has(ruleIndex)) {
      const path = ruleWithStartTokenList.slice(0, i32).map(({ ruleIndex: candidate }) => {
        return candidate;
      });
      let addNew = true;
      for (const rule of this.candidates.rules) {
        if (rule[0] !== ruleIndex || rule[1].ruleList.length !== path.length) {
          continue;
        }
        if (path.every((v2, j) => {
          return v2 === rule[1].ruleList[j];
        })) {
          addNew = false;
          break;
        }
      }
      if (addNew) {
        this.candidates.rules.set(ruleIndex, {
          startTokenIndex,
          ruleList: path
        });
        if (this.showDebugOutput) {
          console.log("=====> collected: ", this.ruleNames[ruleIndex]);
        }
      }
      return true;
    }
    return false;
  }
  /**
   * This method follows the given transition and collects all symbols within the same rule that directly follow it
   * without intermediate transitions to other rules and only if there is a single symbol for a transition.
   *
   * @param transition The transition from which to start.
   * @returns A list of toke types.
   */
  getFollowingTokens(transition) {
    const result = [];
    const pipeline = [transition.target];
    while (pipeline.length > 0) {
      const state = pipeline.pop();
      if (state) {
        state.transitions.forEach((outgoing) => {
          if (outgoing.serializationType === d.ATOM) {
            if (!outgoing.isEpsilon) {
              const list = outgoing.label.toArray();
              if (list.length === 1 && !this.ignoredTokens.has(list[0])) {
                result.push(list[0]);
                pipeline.push(outgoing.target);
              }
            } else {
              pipeline.push(outgoing.target);
            }
          }
        });
      }
    }
    return result;
  }
  /**
   * Entry point for the recursive follow set collection function.
   *
   * @param start Start state.
   * @param stop Stop state.
   * @returns Follow sets.
   */
  determineFollowSets(start, stop) {
    const sets = [];
    const stateStack = [];
    const ruleStack = [];
    const isExhaustive = this.collectFollowSets(start, stop, sets, stateStack, ruleStack);
    const combined = new D();
    for (const set of sets) {
      combined.addSet(set.intervals);
    }
    return { sets, isExhaustive, combined };
  }
  /**
   * Collects possible tokens which could be matched following the given ATN state. This is essentially the same
   * algorithm as used in the LL1Analyzer class, but here we consider predicates also and use no parser rule context.
   *
   * @param s The state to continue from.
   * @param stopState The state which ends the collection routine.
   * @param followSets A pass through parameter to add found sets to.
   * @param stateStack A stack to avoid endless recursions.
   * @param ruleStack The current rule stack.
   * @returns true if the follow sets is exhaustive, i.e. we terminated before the rule end was reached, so no
   * subsequent rules could add tokens
   */
  collectFollowSets(s, stopState, followSets, stateStack, ruleStack) {
    if (stateStack.find((x2) => {
      return x2 === s;
    })) {
      return true;
    }
    stateStack.push(s);
    if (s === stopState || s.stateType === m.RULE_STOP) {
      stateStack.pop();
      return false;
    }
    let isExhaustive = true;
    for (const transition of s.transitions) {
      if (transition.serializationType === d.RULE) {
        const ruleTransition = transition;
        if (ruleStack.indexOf(ruleTransition.target.ruleIndex) !== -1) {
          continue;
        }
        ruleStack.push(ruleTransition.target.ruleIndex);
        const ruleFollowSetsIsExhaustive = this.collectFollowSets(
          transition.target,
          stopState,
          followSets,
          stateStack,
          ruleStack
        );
        ruleStack.pop();
        if (!ruleFollowSetsIsExhaustive) {
          const nextStateFollowSetsIsExhaustive = this.collectFollowSets(
            ruleTransition.followState,
            stopState,
            followSets,
            stateStack,
            ruleStack
          );
          isExhaustive &&= nextStateFollowSetsIsExhaustive;
        }
      } else if (transition.serializationType === d.PREDICATE) {
        if (this.checkPredicate(transition)) {
          const nextStateFollowSetsIsExhaustive = this.collectFollowSets(
            transition.target,
            stopState,
            followSets,
            stateStack,
            ruleStack
          );
          isExhaustive &&= nextStateFollowSetsIsExhaustive;
        }
      } else if (transition.isEpsilon) {
        const nextStateFollowSetsIsExhaustive = this.collectFollowSets(
          transition.target,
          stopState,
          followSets,
          stateStack,
          ruleStack
        );
        isExhaustive &&= nextStateFollowSetsIsExhaustive;
      } else if (transition.serializationType === d.WILDCARD) {
        const set = new FollowSetWithPath();
        set.intervals = D.of(h.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
        set.path = ruleStack.slice();
        followSets.push(set);
      } else {
        let label = transition.label;
        if (label && label.length > 0) {
          if (transition.serializationType === d.NOT_SET) {
            label = label.complement(h.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
          }
          const set = new FollowSetWithPath();
          set.intervals = label ?? new D();
          set.path = ruleStack.slice();
          set.following = this.getFollowingTokens(transition);
          followSets.push(set);
        }
      }
    }
    stateStack.pop();
    return isExhaustive;
  }
  /**
   * Walks the ATN for a single rule only. It returns the token stream position for each path that could be matched
   * in this rule.
   * The result can be empty in case we hit only non-epsilon transitions that didn't match the current input or if we
   * hit the caret position.
   *
   * @param startState The start state.
   * @param tokenListIndex The token index we are currently at.
   * @param callStack The stack that indicates where in the ATN we are currently.
   * @param precedence The current precedence level.
   * @param indentation A value to determine the current indentation when doing debug prints.
   * @returns the set of token stream indexes (which depend on the ways that had to be taken).
   */
  processRule(startState, tokenListIndex, callStack, precedence, indentation) {
    let positionMap = this.shortcutMap.get(startState.ruleIndex);
    if (!positionMap) {
      positionMap = /* @__PURE__ */ new Map();
      this.shortcutMap.set(startState.ruleIndex, positionMap);
    } else {
      if (positionMap.has(tokenListIndex)) {
        if (this.showDebugOutput) {
          console.log("=====> shortcut");
        }
        return positionMap.get(tokenListIndex);
      }
    }
    const result = /* @__PURE__ */ new Set();
    let setsPerState = _CodeCompletionCore.followSetsByATN.get(this.parser.constructor.name);
    if (!setsPerState) {
      setsPerState = /* @__PURE__ */ new Map();
      _CodeCompletionCore.followSetsByATN.set(this.parser.constructor.name, setsPerState);
    }
    let followSets = setsPerState.get(startState.stateNumber);
    if (!followSets) {
      const stop = this.atn.ruleToStopState[startState.ruleIndex];
      followSets = this.determineFollowSets(startState, stop);
      setsPerState.set(startState.stateNumber, followSets);
    }
    const startTokenIndex = this.tokens[tokenListIndex].tokenIndex;
    callStack.push({
      startTokenIndex,
      ruleIndex: startState.ruleIndex
    });
    if (tokenListIndex >= this.tokens.length - 1) {
      if (this.preferredRules.has(startState.ruleIndex)) {
        this.translateStackToRuleIndex(callStack);
      } else {
        for (const set of followSets.sets) {
          const fullPath = callStack.slice();
          const followSetPath = set.path.map((path) => {
            return {
              startTokenIndex,
              ruleIndex: path
            };
          });
          fullPath.push(...followSetPath);
          if (!this.translateStackToRuleIndex(fullPath)) {
            for (const symbol of set.intervals.toArray()) {
              if (!this.ignoredTokens.has(symbol)) {
                if (this.showDebugOutput) {
                  console.log("=====> collected: ", this.vocabulary.getDisplayName(symbol));
                }
                if (!this.candidates.tokens.has(symbol)) {
                  this.candidates.tokens.set(symbol, set.following);
                } else {
                  if (this.candidates.tokens.get(symbol) !== set.following) {
                    this.candidates.tokens.set(symbol, []);
                  }
                }
              }
            }
          }
        }
      }
      if (!followSets.isExhaustive) {
        result.add(tokenListIndex);
      }
      callStack.pop();
      return result;
    } else {
      const currentSymbol = this.tokens[tokenListIndex].type;
      if (followSets.isExhaustive && !followSets.combined.contains(currentSymbol)) {
        callStack.pop();
        return result;
      }
    }
    if (startState.isPrecedenceRule) {
      this.precedenceStack.push(precedence);
    }
    const statePipeline = [];
    let currentEntry;
    statePipeline.push({ state: startState, tokenListIndex });
    while (statePipeline.length > 0) {
      currentEntry = statePipeline.pop();
      ++this.statesProcessed;
      const currentSymbol = this.tokens[currentEntry.tokenListIndex].type;
      const atCaret = currentEntry.tokenListIndex >= this.tokens.length - 1;
      if (this.showDebugOutput) {
        this.printDescription(
          indentation,
          currentEntry.state,
          this.generateBaseDescription(currentEntry.state),
          currentEntry.tokenListIndex
        );
        if (this.showRuleStack) {
          this.printRuleState(callStack);
        }
      }
      if (currentEntry.state.stateType === m.RULE_STOP) {
        result.add(currentEntry.tokenListIndex);
        continue;
      }
      const transitions = currentEntry.state.transitions;
      for (const transition of transitions) {
        switch (transition.serializationType) {
          case d.RULE: {
            const ruleTransition = transition;
            const endStatus = this.processRule(
              transition.target,
              currentEntry.tokenListIndex,
              callStack,
              ruleTransition.precedence,
              indentation + 1
            );
            for (const position of endStatus) {
              statePipeline.push({
                state: transition.followState,
                tokenListIndex: position
              });
            }
            break;
          }
          case d.PREDICATE: {
            if (this.checkPredicate(transition)) {
              statePipeline.push({
                state: transition.target,
                tokenListIndex: currentEntry.tokenListIndex
              });
            }
            break;
          }
          case d.PRECEDENCE: {
            const predTransition = transition;
            if (predTransition.precedence >= this.precedenceStack[this.precedenceStack.length - 1]) {
              statePipeline.push({
                state: transition.target,
                tokenListIndex: currentEntry.tokenListIndex
              });
            }
            break;
          }
          case d.WILDCARD: {
            if (atCaret) {
              if (!this.translateStackToRuleIndex(callStack)) {
                for (const token of D.of(h.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType).toArray()) {
                  if (!this.ignoredTokens.has(token)) {
                    this.candidates.tokens.set(token, []);
                  }
                }
              }
            } else {
              statePipeline.push({
                state: transition.target,
                tokenListIndex: currentEntry.tokenListIndex + 1
              });
            }
            break;
          }
          default: {
            if (transition.isEpsilon) {
              statePipeline.push({
                state: transition.target,
                tokenListIndex: currentEntry.tokenListIndex
              });
              continue;
            }
            let set = transition.label;
            if (set && set.length > 0) {
              if (transition.serializationType === d.NOT_SET) {
                set = set.complement(h.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
              }
              if (atCaret) {
                if (!this.translateStackToRuleIndex(callStack)) {
                  const list = set.toArray();
                  const hasTokenSequence = list.length === 1;
                  for (const symbol of list) {
                    if (!this.ignoredTokens.has(symbol)) {
                      if (this.showDebugOutput) {
                        console.log(
                          "=====> collected: ",
                          this.vocabulary.getDisplayName(symbol)
                        );
                      }
                      const followingTokens = hasTokenSequence ? this.getFollowingTokens(transition) : [];
                      if (!this.candidates.tokens.has(symbol)) {
                        this.candidates.tokens.set(symbol, followingTokens);
                      } else {
                        this.candidates.tokens.set(
                          symbol,
                          longestCommonPrefix(
                            followingTokens,
                            this.candidates.tokens.get(symbol)
                          )
                        );
                      }
                    }
                  }
                }
              } else {
                if (set.contains(currentSymbol)) {
                  if (this.showDebugOutput) {
                    console.log("=====> consumed: ", this.vocabulary.getDisplayName(currentSymbol));
                  }
                  statePipeline.push({
                    state: transition.target,
                    tokenListIndex: currentEntry.tokenListIndex + 1
                  });
                }
              }
            }
          }
        }
      }
    }
    callStack.pop();
    if (startState.isPrecedenceRule) {
      this.precedenceStack.pop();
    }
    positionMap.set(tokenListIndex, result);
    return result;
  }
  generateBaseDescription(state) {
    const stateValue = state.stateNumber === _.INVALID_STATE_NUMBER ? "Invalid" : state.stateNumber;
    return `[${stateValue} ${_CodeCompletionCore.atnStateTypeMap[state.stateType]}] in ${this.ruleNames[state.ruleIndex]}`;
  }
  printDescription(indentation, state, baseDescription, tokenIndex) {
    const indent = "  ".repeat(indentation);
    let output = indent;
    let transitionDescription = "";
    if (this.debugOutputWithTransitions) {
      for (const transition of state.transitions) {
        let labels = "";
        const symbols = transition.label ? transition.label.toArray() : [];
        if (symbols.length > 2) {
          labels = this.vocabulary.getDisplayName(symbols[0]) + " .. " + this.vocabulary.getDisplayName(symbols[symbols.length - 1]);
        } else {
          for (const symbol of symbols) {
            if (labels.length > 0) {
              labels += ", ";
            }
            labels += this.vocabulary.getDisplayName(symbol);
          }
        }
        if (labels.length === 0) {
          labels = "\u03B5";
        }
        transitionDescription += `
${indent}	(${labels}) [${transition.target.stateNumber} ${_CodeCompletionCore.atnStateTypeMap[transition.target.stateType]}] in ${this.ruleNames[transition.target.ruleIndex]}`;
      }
    }
    if (tokenIndex >= this.tokens.length - 1) {
      output += `<<${this.tokenStartIndex + tokenIndex}>> `;
    } else {
      output += `<${this.tokenStartIndex + tokenIndex}> `;
    }
    console.log(output + "Current state: " + baseDescription + transitionDescription);
  }
  printRuleState(stack) {
    if (stack.length === 0) {
      console.log("<empty stack>");
      return;
    }
    for (const rule of stack) {
      console.log(this.ruleNames[rule.ruleIndex]);
    }
  }
};

// src/SymbolTable.ts
var SymbolTable = class extends ScopedSymbol {
  constructor(name, options) {
    super(name);
    this.options = options;
  }
  /**  Other symbol information available to this instance. */
  dependencies = /* @__PURE__ */ new Set();
  get info() {
    return {
      dependencyCount: this.dependencies.size,
      symbolCount: this.children.length
    };
  }
  clear() {
    super.clear();
    this.dependencies.clear();
  }
  addDependencies(...tables) {
    tables.forEach((value) => {
      this.dependencies.add(value);
    });
  }
  removeDependency(table) {
    if (this.dependencies.has(table)) {
      this.dependencies.delete(table);
    }
  }
  addNewSymbolOfType(t, parent, ...args) {
    const result = new t(...args);
    if (!parent || parent === this) {
      this.addSymbol(result);
    } else {
      parent.addSymbol(result);
    }
    return result;
  }
  async addNewNamespaceFromPath(parent, path, delimiter = ".") {
    const parts = path.split(delimiter);
    let i32 = 0;
    let currentParent = parent === void 0 ? this : parent;
    while (i32 < parts.length - 1) {
      let namespace = await currentParent.resolve(parts[i32], true);
      if (namespace === void 0) {
        namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i32]);
      }
      currentParent = namespace;
      ++i32;
    }
    return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);
  }
  addNewNamespaceFromPathSync(parent, path, delimiter = ".") {
    const parts = path.split(delimiter);
    let i32 = 0;
    let currentParent = parent === void 0 ? this : parent;
    while (i32 < parts.length - 1) {
      let namespace = currentParent.resolveSync(parts[i32], true);
      if (namespace === void 0) {
        namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i32]);
      }
      currentParent = namespace;
      ++i32;
    }
    return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);
  }
  async getAllSymbols(t, localOnly = false) {
    const result = await super.getAllSymbols(t, localOnly);
    if (!localOnly) {
      const dependencyResults = await Promise.all([...this.dependencies].map((dependency) => {
        return dependency.getAllSymbols(t, localOnly);
      }));
      dependencyResults.forEach((value) => {
        result.push(...value);
      });
    }
    return result;
  }
  getAllSymbolsSync(t, localOnly = false) {
    const result = super.getAllSymbolsSync(t, localOnly);
    if (!localOnly) {
      this.dependencies.forEach((dependency) => {
        result.push(...dependency.getAllSymbolsSync(t, localOnly));
      });
    }
    return result;
  }
  async symbolWithContext(context) {
    const findRecursive = (symbol) => {
      if (symbol.context === context) {
        return symbol;
      }
      if (symbol instanceof ScopedSymbol) {
        for (const child of symbol.children) {
          const result = findRecursive(child);
          if (result) {
            return result;
          }
        }
      }
      return void 0;
    };
    let symbols = await this.getAllSymbols(BaseSymbol);
    for (const symbol of symbols) {
      const result = findRecursive(symbol);
      if (result) {
        return result;
      }
    }
    for (const dependency of this.dependencies) {
      symbols = await dependency.getAllSymbols(BaseSymbol);
      for (const symbol of symbols) {
        const result = findRecursive(symbol);
        if (result) {
          return result;
        }
      }
    }
    return void 0;
  }
  symbolWithContextSync(context) {
    const findRecursive = (symbol) => {
      if (symbol.context === context) {
        return symbol;
      }
      if (symbol instanceof ScopedSymbol) {
        for (const child of symbol.children) {
          const result = findRecursive(child);
          if (result) {
            return result;
          }
        }
      }
      return void 0;
    };
    let symbols = this.getAllSymbolsSync(BaseSymbol);
    for (const symbol of symbols) {
      const result = findRecursive(symbol);
      if (result) {
        return result;
      }
    }
    for (const dependency of this.dependencies) {
      symbols = dependency.getAllSymbolsSync(BaseSymbol);
      for (const symbol of symbols) {
        const result = findRecursive(symbol);
        if (result) {
          return result;
        }
      }
    }
    return void 0;
  }
  async resolve(name, localOnly = false) {
    let result = await super.resolve(name, localOnly);
    if (!result && !localOnly) {
      for (const dependency of this.dependencies) {
        result = await dependency.resolve(name, false);
        if (result) {
          return result;
        }
      }
    }
    return result;
  }
  resolveSync(name, localOnly = false) {
    let result = super.resolveSync(name, localOnly);
    if (!result && !localOnly) {
      for (const dependency of this.dependencies) {
        result = dependency.resolveSync(name, false);
        if (result) {
          return result;
        }
      }
    }
    return result;
  }
};
export {
  ArrayType,
  BaseSymbol,
  BlockSymbol,
  CandidatesCollection,
  ClassSymbol,
  CodeCompletionCore,
  DuplicateSymbolError,
  FieldSymbol,
  FundamentalType,
  InterfaceSymbol,
  LiteralSymbol,
  MemberVisibility,
  MethodFlags,
  MethodSymbol,
  Modifier,
  NamespaceSymbol,
  ParameterSymbol,
  ReferenceKind,
  RoutineSymbol,
  ScopedSymbol,
  SymbolTable,
  TypeAlias,
  TypeKind,
  TypedSymbol,
  VariableSymbol
};
